#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 27 16:50:13 2015 by generateDS.py version 2.17a.
#
# Command line options:
#   ('-o', 'SRA_submission.py')
#   ('-s', 'SRA_submission_sub.py')
#
# Command line arguments:
#   SRA.submission.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "SRA_submission.py" -s "SRA_submission_sub.py" SRA.submission.xsd
#
# Current working directory (os.getcwd()):
#   sra-xml1.5_15July
#

import base64
import datetime as datetime_
import re as re_
import sys
import warnings as warnings_

from lxml import etree as etree_

Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class SubmissionType(GeneratedsSuper):
    """A Submission type is used to describe an object that contains
    submission actions to be performed by the archive. Submitter
    assigned preparation date of this submission object. Submitter
    assigned comment. Laboratory name within submitting institution."""
    subclass = None
    superclass = None
    def __init__(self, submission_date=None, broker_name=None, alias=None, center_name=None, accession=None, lab_name=None, submission_comment=None, IDENTIFIERS=None, TITLE=None, CONTACTS=None, ACTIONS=None, SUBMISSION_LINKS=None, SUBMISSION_ATTRIBUTES=None):
        self.original_tagname_ = None
        if isinstance(submission_date, str):
            initvalue_ = datetime_.datetime.strptime(submission_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = submission_date
        self.submission_date = initvalue_
        self.broker_name = _cast(None, broker_name)
        self.alias = _cast(None, alias)
        self.center_name = _cast(None, center_name)
        self.accession = _cast(None, accession)
        self.lab_name = _cast(None, lab_name)
        self.submission_comment = _cast(None, submission_comment)
        self.IDENTIFIERS = IDENTIFIERS
        self.TITLE = TITLE
        self.CONTACTS = CONTACTS
        self.ACTIONS = ACTIONS
        self.SUBMISSION_LINKS = SUBMISSION_LINKS
        self.SUBMISSION_ATTRIBUTES = SUBMISSION_ATTRIBUTES
    def factory(*args_, **kwargs_):
        if SubmissionType.subclass:
            return SubmissionType.subclass(*args_, **kwargs_)
        else:
            return SubmissionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDENTIFIERS(self): return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS): self.IDENTIFIERS = IDENTIFIERS
    def get_TITLE(self): return self.TITLE
    def set_TITLE(self, TITLE): self.TITLE = TITLE
    def get_CONTACTS(self): return self.CONTACTS
    def set_CONTACTS(self, CONTACTS): self.CONTACTS = CONTACTS
    def get_ACTIONS(self): return self.ACTIONS
    def set_ACTIONS(self, ACTIONS): self.ACTIONS = ACTIONS
    def get_SUBMISSION_LINKS(self): return self.SUBMISSION_LINKS
    def set_SUBMISSION_LINKS(self, SUBMISSION_LINKS): self.SUBMISSION_LINKS = SUBMISSION_LINKS
    def get_SUBMISSION_ATTRIBUTES(self): return self.SUBMISSION_ATTRIBUTES
    def set_SUBMISSION_ATTRIBUTES(self, SUBMISSION_ATTRIBUTES): self.SUBMISSION_ATTRIBUTES = SUBMISSION_ATTRIBUTES
    def get_submission_date(self): return self.submission_date
    def set_submission_date(self, submission_date): self.submission_date = submission_date
    def get_broker_name(self): return self.broker_name
    def set_broker_name(self, broker_name): self.broker_name = broker_name
    def get_alias(self): return self.alias
    def set_alias(self, alias): self.alias = alias
    def get_center_name(self): return self.center_name
    def set_center_name(self, center_name): self.center_name = center_name
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_lab_name(self): return self.lab_name
    def set_lab_name(self, lab_name): self.lab_name = lab_name
    def get_submission_comment(self): return self.submission_comment
    def set_submission_comment(self, submission_comment): self.submission_comment = submission_comment
    def hasContent_(self):
        if (
            self.IDENTIFIERS is not None or
            self.TITLE is not None or
            self.CONTACTS is not None or
            self.ACTIONS is not None or
            self.SUBMISSION_LINKS is not None or
            self.SUBMISSION_ATTRIBUTES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubmissionType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmissionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubmissionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubmissionType'):
        if self.submission_date is not None and 'submission_date' not in already_processed:
            already_processed.add('submission_date')
            outfile.write(' submission_date="%s"' % self.gds_format_datetime(self.submission_date, input_name='submission_date'))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            outfile.write(' broker_name=%s' % (self.gds_format_string(quote_attrib(self.broker_name).encode(ExternalEncoding).decode(), input_name='broker_name'), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_format_string(quote_attrib(self.alias).encode(ExternalEncoding).decode(), input_name='alias'), ))
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            outfile.write(' center_name=%s' % (self.gds_format_string(quote_attrib(self.center_name).encode(ExternalEncoding).decode(), input_name='center_name'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(), input_name='accession'), ))
        if self.lab_name is not None and 'lab_name' not in already_processed:
            already_processed.add('lab_name')
            outfile.write(' lab_name=%s' % (self.gds_format_string(quote_attrib(self.lab_name).encode(ExternalEncoding).decode(), input_name='lab_name'), ))
        if self.submission_comment is not None and 'submission_comment' not in already_processed:
            already_processed.add('submission_comment')
            outfile.write(' submission_comment=%s' % (self.gds_format_string(quote_attrib(self.submission_comment).encode(ExternalEncoding).decode(), input_name='submission_comment'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubmissionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)
        if self.TITLE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespace_, self.gds_format_string(quote_xml(self.TITLE).encode(ExternalEncoding).decode(), input_name='TITLE'), namespace_, eol_))
        if self.CONTACTS is not None:
            self.CONTACTS.export(outfile, level, namespace_, name_='CONTACTS', pretty_print=pretty_print)
        if self.ACTIONS is not None:
            self.ACTIONS.export(outfile, level, namespace_, name_='ACTIONS', pretty_print=pretty_print)
        if self.SUBMISSION_LINKS is not None:
            self.SUBMISSION_LINKS.export(outfile, level, namespace_, name_='SUBMISSION_LINKS', pretty_print=pretty_print)
        if self.SUBMISSION_ATTRIBUTES is not None:
            self.SUBMISSION_ATTRIBUTES.export(outfile, level, namespace_, name_='SUBMISSION_ATTRIBUTES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('submission_date', node)
        if value is not None and 'submission_date' not in already_processed:
            already_processed.add('submission_date')
            try:
                self.submission_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (submission_date): %s' % exp)
        value = find_attr_value_('broker_name', node)
        if value is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            self.broker_name = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('center_name', node)
        if value is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            self.center_name = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('lab_name', node)
        if value is not None and 'lab_name' not in already_processed:
            already_processed.add('lab_name')
            self.lab_name = value
        value = find_attr_value_('submission_comment', node)
        if value is not None and 'submission_comment' not in already_processed:
            already_processed.add('submission_comment')
            self.submission_comment = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
        elif nodeName_ == 'TITLE':
            TITLE_ = child_.text
            TITLE_ = self.gds_validate_string(TITLE_, node, 'TITLE')
            self.TITLE = TITLE_
        elif nodeName_ == 'CONTACTS':
            obj_ = CONTACTSType.factory()
            obj_.build(child_)
            self.CONTACTS = obj_
            obj_.original_tagname_ = 'CONTACTS'
        elif nodeName_ == 'ACTIONS':
            obj_ = ACTIONSType.factory()
            obj_.build(child_)
            self.ACTIONS = obj_
            obj_.original_tagname_ = 'ACTIONS'
        elif nodeName_ == 'SUBMISSION_LINKS':
            obj_ = SUBMISSION_LINKSType.factory()
            obj_.build(child_)
            self.SUBMISSION_LINKS = obj_
            obj_.original_tagname_ = 'SUBMISSION_LINKS'
        elif nodeName_ == 'SUBMISSION_ATTRIBUTES':
            obj_ = SUBMISSION_ATTRIBUTESType.factory()
            obj_.build(child_)
            self.SUBMISSION_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'SUBMISSION_ATTRIBUTES'
# end class SubmissionType


class SubmissionSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SUBMISSION=None):
        self.original_tagname_ = None
        if SUBMISSION is None:
            self.SUBMISSION = []
        else:
            self.SUBMISSION = SUBMISSION
    def factory(*args_, **kwargs_):
        if SubmissionSetType.subclass:
            return SubmissionSetType.subclass(*args_, **kwargs_)
        else:
            return SubmissionSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SUBMISSION(self): return self.SUBMISSION
    def set_SUBMISSION(self, SUBMISSION): self.SUBMISSION = SUBMISSION
    def add_SUBMISSION(self, value): self.SUBMISSION.append(value)
    def insert_SUBMISSION_at(self, index, value): self.SUBMISSION.insert(index, value)
    def replace_SUBMISSION_at(self, index, value): self.SUBMISSION[index] = value
    def hasContent_(self):
        if (
            self.SUBMISSION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubmissionSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmissionSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubmissionSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubmissionSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SubmissionSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SUBMISSION_ in self.SUBMISSION:
            SUBMISSION_.export(outfile, level, namespace_, name_='SUBMISSION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SUBMISSION':
            obj_ = SubmissionType.factory()
            obj_.build(child_)
            self.SUBMISSION.append(obj_)
            obj_.original_tagname_ = 'SUBMISSION'
# end class SubmissionSetType


class NameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding).decode())
            self.exportChildren(outfile, level + 1, namespace_='', name_='NameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameType


class QualifiedNameType(NameType):
    """A string value that constrains the domain of named identifiers
    (namespace)."""
    subclass = None
    superclass = NameType
    def __init__(self, namespace=None, valueOf_=None):
        self.original_tagname_ = None
        super(QualifiedNameType, self).__init__(valueOf_, )
        self.namespace = _cast(None, namespace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if QualifiedNameType.subclass:
            return QualifiedNameType.subclass(*args_, **kwargs_)
        else:
            return QualifiedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(QualifiedNameType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QualifiedNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding).decode())
            self.exportChildren(outfile, level + 1, namespace_='', name_='QualifiedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QualifiedNameType'):
        super(QualifiedNameType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding).decode(), input_name='namespace'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QualifiedNameType', fromsubclass_=False, pretty_print=True):
        super(QualifiedNameType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        super(QualifiedNameType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QualifiedNameType


class IdentifierType(GeneratedsSuper):
    """Set of record identifiers."""
    subclass = None
    superclass = None
    def __init__(self, PRIMARY_ID=None, SECONDARY_ID=None, EXTERNAL_ID=None, SUBMITTER_ID=None, UUID=None):
        self.original_tagname_ = None
        self.PRIMARY_ID = PRIMARY_ID
        if SECONDARY_ID is None:
            self.SECONDARY_ID = []
        else:
            self.SECONDARY_ID = SECONDARY_ID
        if EXTERNAL_ID is None:
            self.EXTERNAL_ID = []
        else:
            self.EXTERNAL_ID = EXTERNAL_ID
        self.SUBMITTER_ID = SUBMITTER_ID
        if UUID is None:
            self.UUID = []
        else:
            self.UUID = UUID
    def factory(*args_, **kwargs_):
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PRIMARY_ID(self): return self.PRIMARY_ID
    def set_PRIMARY_ID(self, PRIMARY_ID): self.PRIMARY_ID = PRIMARY_ID
    def get_SECONDARY_ID(self): return self.SECONDARY_ID
    def set_SECONDARY_ID(self, SECONDARY_ID): self.SECONDARY_ID = SECONDARY_ID
    def add_SECONDARY_ID(self, value): self.SECONDARY_ID.append(value)
    def insert_SECONDARY_ID_at(self, index, value): self.SECONDARY_ID.insert(index, value)
    def replace_SECONDARY_ID_at(self, index, value): self.SECONDARY_ID[index] = value
    def get_EXTERNAL_ID(self): return self.EXTERNAL_ID
    def set_EXTERNAL_ID(self, EXTERNAL_ID): self.EXTERNAL_ID = EXTERNAL_ID
    def add_EXTERNAL_ID(self, value): self.EXTERNAL_ID.append(value)
    def insert_EXTERNAL_ID_at(self, index, value): self.EXTERNAL_ID.insert(index, value)
    def replace_EXTERNAL_ID_at(self, index, value): self.EXTERNAL_ID[index] = value
    def get_SUBMITTER_ID(self): return self.SUBMITTER_ID
    def set_SUBMITTER_ID(self, SUBMITTER_ID): self.SUBMITTER_ID = SUBMITTER_ID
    def get_UUID(self): return self.UUID
    def set_UUID(self, UUID): self.UUID = UUID
    def add_UUID(self, value): self.UUID.append(value)
    def insert_UUID_at(self, index, value): self.UUID.insert(index, value)
    def replace_UUID_at(self, index, value): self.UUID[index] = value
    def hasContent_(self):
        if (
            self.PRIMARY_ID is not None or
            self.SECONDARY_ID or
            self.EXTERNAL_ID or
            self.SUBMITTER_ID is not None or
            self.UUID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifierType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PRIMARY_ID is not None:
            self.PRIMARY_ID.export(outfile, level, namespace_, name_='PRIMARY_ID', pretty_print=pretty_print)
        for SECONDARY_ID_ in self.SECONDARY_ID:
            SECONDARY_ID_.export(outfile, level, namespace_, name_='SECONDARY_ID', pretty_print=pretty_print)
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            EXTERNAL_ID_.export(outfile, level, namespace_, name_='EXTERNAL_ID', pretty_print=pretty_print)
        if self.SUBMITTER_ID is not None:
            self.SUBMITTER_ID.export(outfile, level, namespace_, name_='SUBMITTER_ID', pretty_print=pretty_print)
        for UUID_ in self.UUID:
            UUID_.export(outfile, level, namespace_, name_='UUID', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PRIMARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PRIMARY_ID = obj_
            obj_.original_tagname_ = 'PRIMARY_ID'
        elif nodeName_ == 'SECONDARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SECONDARY_ID.append(obj_)
            obj_.original_tagname_ = 'SECONDARY_ID'
        elif nodeName_ == 'EXTERNAL_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.EXTERNAL_ID.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_ID'
        elif nodeName_ == 'SUBMITTER_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.SUBMITTER_ID = obj_
            obj_.original_tagname_ = 'SUBMITTER_ID'
        elif nodeName_ == 'UUID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.UUID.append(obj_)
            obj_.original_tagname_ = 'UUID'
# end class IdentifierType


class XRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.LABEL = LABEL
    def factory(*args_, **kwargs_):
        if XRefType.subclass:
            return XRefType.subclass(*args_, **kwargs_)
        else:
            return XRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def hasContent_(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='XRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding).decode(), input_name='DB'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding).decode(), input_name='ID'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
# end class XRefType


class URLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URLType.subclass:
            return URLType.subclass(*args_, **kwargs_)
        else:
            return URLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding).decode(), input_name='URL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URLType


class AttributeType(GeneratedsSuper):
    """Reusable attributes to encode tag-value pairs with optional units."""
    subclass = None
    superclass = None
    def __init__(self, TAG=None, VALUE=None, UNITS=None):
        self.original_tagname_ = None
        self.TAG = TAG
        self.VALUE = VALUE
        self.UNITS = UNITS
    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TAG(self): return self.TAG
    def set_TAG(self, TAG): self.TAG = TAG
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def get_UNITS(self): return self.UNITS
    def set_UNITS(self, UNITS): self.UNITS = UNITS
    def hasContent_(self):
        if (
            self.TAG is not None or
            self.VALUE is not None or
            self.UNITS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAG>%s</%sTAG>%s' % (namespace_, self.gds_format_string(quote_xml(self.TAG).encode(ExternalEncoding).decode(), input_name='TAG'), namespace_, eol_))
        if self.VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespace_, self.gds_format_string(quote_xml(self.VALUE).encode(ExternalEncoding).decode(), input_name='VALUE'), namespace_, eol_))
        if self.UNITS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNITS>%s</%sUNITS>%s' % (namespace_, self.gds_format_string(quote_xml(self.UNITS).encode(ExternalEncoding).decode(), input_name='UNITS'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TAG':
            TAG_ = child_.text
            TAG_ = self.gds_validate_string(TAG_, node, 'TAG')
            self.TAG = TAG_
        elif nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE = VALUE_
        elif nodeName_ == 'UNITS':
            UNITS_ = child_.text
            UNITS_ = self.gds_validate_string(UNITS_, node, 'UNITS')
            self.UNITS = UNITS_
# end class AttributeType


class LinkType(GeneratedsSuper):
    """Reusable external links type to encode URL links, Entrez links, and
    db_xref links."""
    subclass = None
    superclass = None
    def __init__(self, URL_LINK=None, XREF_LINK=None, ENTREZ_LINK=None):
        self.original_tagname_ = None
        self.URL_LINK = URL_LINK
        self.XREF_LINK = XREF_LINK
        self.ENTREZ_LINK = ENTREZ_LINK
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL_LINK(self): return self.URL_LINK
    def set_URL_LINK(self, URL_LINK): self.URL_LINK = URL_LINK
    def get_XREF_LINK(self): return self.XREF_LINK
    def set_XREF_LINK(self, XREF_LINK): self.XREF_LINK = XREF_LINK
    def get_ENTREZ_LINK(self): return self.ENTREZ_LINK
    def set_ENTREZ_LINK(self, ENTREZ_LINK): self.ENTREZ_LINK = ENTREZ_LINK
    def hasContent_(self):
        if (
            self.URL_LINK is not None or
            self.XREF_LINK is not None or
            self.ENTREZ_LINK is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL_LINK is not None:
            self.URL_LINK.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
        if self.XREF_LINK is not None:
            self.XREF_LINK.export(outfile, level, namespace_, name_='XREF_LINK', pretty_print=pretty_print)
        if self.ENTREZ_LINK is not None:
            self.ENTREZ_LINK.export(outfile, level, namespace_, name_='ENTREZ_LINK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType.factory()
            obj_.build(child_)
            self.URL_LINK = obj_
            obj_.original_tagname_ = 'URL_LINK'
        elif nodeName_ == 'XREF_LINK':
            obj_ = XRefType.factory()
            obj_.build(child_)
            self.XREF_LINK = obj_
            obj_.original_tagname_ = 'XREF_LINK'
        elif nodeName_ == 'ENTREZ_LINK':
            obj_ = ENTREZ_LINKType.factory()
            obj_.build(child_)
            self.ENTREZ_LINK = obj_
            obj_.original_tagname_ = 'ENTREZ_LINK'
# end class LinkType


class SpotDescriptorType(GeneratedsSuper):
    """The SPOT_DESCRIPTOR specifies how to decode the individual reads of
    interest from the monolithic spot sequence. The spot descriptor
    contains aspects of the experimental design, platform, and
    processing information. There will be two methods of
    specification: one will be an index into a table of typical
    decodings, the other being an exact specification."""
    subclass = None
    superclass = None
    def __init__(self, SPOT_DECODE_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def factory(*args_, **kwargs_):
        if SpotDescriptorType.subclass:
            return SpotDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SpotDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPOT_DECODE_SPEC(self): return self.SPOT_DECODE_SPEC
    def set_SPOT_DECODE_SPEC(self, SPOT_DECODE_SPEC): self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def hasContent_(self):
        if (
            self.SPOT_DECODE_SPEC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpotDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpotDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpotDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpotDescriptorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpotDescriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_DECODE_SPEC is not None:
            self.SPOT_DECODE_SPEC.export(outfile, level, namespace_, name_='SPOT_DECODE_SPEC', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_DECODE_SPEC':
            obj_ = SPOT_DECODE_SPECType.factory()
            obj_.build(child_)
            self.SPOT_DECODE_SPEC = obj_
            obj_.original_tagname_ = 'SPOT_DECODE_SPEC'
# end class SpotDescriptorType


class PlatformType(GeneratedsSuper):
    """The PLATFORM specifies the sequencing platform."""
    subclass = None
    superclass = None
    def __init__(self, LS454=None, ILLUMINA=None, HELICOS=None, ABI_SOLID=None, COMPLETE_GENOMICS=None, PACBIO_SMRT=None, ION_TORRENT=None, CAPILLARY=None):
        self.original_tagname_ = None
        self.LS454 = LS454
        self.ILLUMINA = ILLUMINA
        self.HELICOS = HELICOS
        self.ABI_SOLID = ABI_SOLID
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
        self.PACBIO_SMRT = PACBIO_SMRT
        self.ION_TORRENT = ION_TORRENT
        self.CAPILLARY = CAPILLARY
    def factory(*args_, **kwargs_):
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LS454(self): return self.LS454
    def set_LS454(self, LS454): self.LS454 = LS454
    def get_ILLUMINA(self): return self.ILLUMINA
    def set_ILLUMINA(self, ILLUMINA): self.ILLUMINA = ILLUMINA
    def get_HELICOS(self): return self.HELICOS
    def set_HELICOS(self, HELICOS): self.HELICOS = HELICOS
    def get_ABI_SOLID(self): return self.ABI_SOLID
    def set_ABI_SOLID(self, ABI_SOLID): self.ABI_SOLID = ABI_SOLID
    def get_COMPLETE_GENOMICS(self): return self.COMPLETE_GENOMICS
    def set_COMPLETE_GENOMICS(self, COMPLETE_GENOMICS): self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
    def get_PACBIO_SMRT(self): return self.PACBIO_SMRT
    def set_PACBIO_SMRT(self, PACBIO_SMRT): self.PACBIO_SMRT = PACBIO_SMRT
    def get_ION_TORRENT(self): return self.ION_TORRENT
    def set_ION_TORRENT(self, ION_TORRENT): self.ION_TORRENT = ION_TORRENT
    def get_CAPILLARY(self): return self.CAPILLARY
    def set_CAPILLARY(self, CAPILLARY): self.CAPILLARY = CAPILLARY
    def hasContent_(self):
        if (
            self.LS454 is not None or
            self.ILLUMINA is not None or
            self.HELICOS is not None or
            self.ABI_SOLID is not None or
            self.COMPLETE_GENOMICS is not None or
            self.PACBIO_SMRT is not None or
            self.ION_TORRENT is not None or
            self.CAPILLARY is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PlatformType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LS454 is not None:
            self.LS454.export(outfile, level, namespace_, name_='LS454', pretty_print=pretty_print)
        if self.ILLUMINA is not None:
            self.ILLUMINA.export(outfile, level, namespace_, name_='ILLUMINA', pretty_print=pretty_print)
        if self.HELICOS is not None:
            self.HELICOS.export(outfile, level, namespace_, name_='HELICOS', pretty_print=pretty_print)
        if self.ABI_SOLID is not None:
            self.ABI_SOLID.export(outfile, level, namespace_, name_='ABI_SOLID', pretty_print=pretty_print)
        if self.COMPLETE_GENOMICS is not None:
            self.COMPLETE_GENOMICS.export(outfile, level, namespace_, name_='COMPLETE_GENOMICS', pretty_print=pretty_print)
        if self.PACBIO_SMRT is not None:
            self.PACBIO_SMRT.export(outfile, level, namespace_, name_='PACBIO_SMRT', pretty_print=pretty_print)
        if self.ION_TORRENT is not None:
            self.ION_TORRENT.export(outfile, level, namespace_, name_='ION_TORRENT', pretty_print=pretty_print)
        if self.CAPILLARY is not None:
            self.CAPILLARY.export(outfile, level, namespace_, name_='CAPILLARY', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LS454':
            obj_ = LS454Type.factory()
            obj_.build(child_)
            self.LS454 = obj_
            obj_.original_tagname_ = 'LS454'
        elif nodeName_ == 'ILLUMINA':
            obj_ = ILLUMINAType.factory()
            obj_.build(child_)
            self.ILLUMINA = obj_
            obj_.original_tagname_ = 'ILLUMINA'
        elif nodeName_ == 'HELICOS':
            obj_ = HELICOSType.factory()
            obj_.build(child_)
            self.HELICOS = obj_
            obj_.original_tagname_ = 'HELICOS'
        elif nodeName_ == 'ABI_SOLID':
            obj_ = ABI_SOLIDType.factory()
            obj_.build(child_)
            self.ABI_SOLID = obj_
            obj_.original_tagname_ = 'ABI_SOLID'
        elif nodeName_ == 'COMPLETE_GENOMICS':
            obj_ = COMPLETE_GENOMICSType.factory()
            obj_.build(child_)
            self.COMPLETE_GENOMICS = obj_
            obj_.original_tagname_ = 'COMPLETE_GENOMICS'
        elif nodeName_ == 'PACBIO_SMRT':
            obj_ = PACBIO_SMRTType.factory()
            obj_.build(child_)
            self.PACBIO_SMRT = obj_
            obj_.original_tagname_ = 'PACBIO_SMRT'
        elif nodeName_ == 'ION_TORRENT':
            obj_ = ION_TORRENTType.factory()
            obj_.build(child_)
            self.ION_TORRENT = obj_
            obj_.original_tagname_ = 'ION_TORRENT'
        elif nodeName_ == 'CAPILLARY':
            obj_ = CAPILLARYType.factory()
            obj_.build(child_)
            self.CAPILLARY = obj_
            obj_.original_tagname_ = 'CAPILLARY'
# end class PlatformType


class SequencingDirectivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_DEMUX_DIRECTIVE=None):
        self.original_tagname_ = None
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
        self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
    def factory(*args_, **kwargs_):
        if SequencingDirectivesType.subclass:
            return SequencingDirectivesType.subclass(*args_, **kwargs_)
        else:
            return SequencingDirectivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SAMPLE_DEMUX_DIRECTIVE(self): return self.SAMPLE_DEMUX_DIRECTIVE
    def set_SAMPLE_DEMUX_DIRECTIVE(self, SAMPLE_DEMUX_DIRECTIVE): self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
    def validate_SAMPLE_DEMUX_DIRECTIVEType(self, value):
        # Validate type SAMPLE_DEMUX_DIRECTIVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['leave_as_pool', 'submitter_demultiplexed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SAMPLE_DEMUX_DIRECTIVEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SAMPLE_DEMUX_DIRECTIVE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequencingDirectivesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequencingDirectivesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequencingDirectivesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequencingDirectivesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequencingDirectivesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSAMPLE_DEMUX_DIRECTIVE>%s</%sSAMPLE_DEMUX_DIRECTIVE>%s' % (namespace_, self.gds_format_string(quote_xml(self.SAMPLE_DEMUX_DIRECTIVE).encode(ExternalEncoding).decode(), input_name='SAMPLE_DEMUX_DIRECTIVE'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SAMPLE_DEMUX_DIRECTIVE':
            SAMPLE_DEMUX_DIRECTIVE_ = child_.text
            SAMPLE_DEMUX_DIRECTIVE_ = self.gds_validate_string(SAMPLE_DEMUX_DIRECTIVE_, node, 'SAMPLE_DEMUX_DIRECTIVE')
            self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE_
            # validate type SAMPLE_DEMUX_DIRECTIVEType
            self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
# end class SequencingDirectivesType


class PipelineType(GeneratedsSuper):
    """The PipelineType identifies the sequence or tree of actions to
    process the sequencing data."""
    subclass = None
    superclass = None
    def __init__(self, PIPE_SECTION=None):
        self.original_tagname_ = None
        if PIPE_SECTION is None:
            self.PIPE_SECTION = []
        else:
            self.PIPE_SECTION = PIPE_SECTION
    def factory(*args_, **kwargs_):
        if PipelineType.subclass:
            return PipelineType.subclass(*args_, **kwargs_)
        else:
            return PipelineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PIPE_SECTION(self): return self.PIPE_SECTION
    def set_PIPE_SECTION(self, PIPE_SECTION): self.PIPE_SECTION = PIPE_SECTION
    def add_PIPE_SECTION(self, value): self.PIPE_SECTION.append(value)
    def insert_PIPE_SECTION_at(self, index, value): self.PIPE_SECTION.insert(index, value)
    def replace_PIPE_SECTION_at(self, index, value): self.PIPE_SECTION[index] = value
    def hasContent_(self):
        if (
            self.PIPE_SECTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PipelineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PipelineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PipelineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PipelineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PIPE_SECTION_ in self.PIPE_SECTION:
            PIPE_SECTION_.export(outfile, level, namespace_, name_='PIPE_SECTION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPE_SECTION':
            obj_ = PIPE_SECTIONType.factory()
            obj_.build(child_)
            self.PIPE_SECTION.append(obj_)
            obj_.original_tagname_ = 'PIPE_SECTION'
# end class PipelineType


class ReferenceAssemblyType(GeneratedsSuper):
    """Reference assembly details."""
    subclass = None
    superclass = None
    def __init__(self, STANDARD=None, CUSTOM=None):
        self.original_tagname_ = None
        self.STANDARD = STANDARD
        self.CUSTOM = CUSTOM
    def factory(*args_, **kwargs_):
        if ReferenceAssemblyType.subclass:
            return ReferenceAssemblyType.subclass(*args_, **kwargs_)
        else:
            return ReferenceAssemblyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STANDARD(self): return self.STANDARD
    def set_STANDARD(self, STANDARD): self.STANDARD = STANDARD
    def get_CUSTOM(self): return self.CUSTOM
    def set_CUSTOM(self, CUSTOM): self.CUSTOM = CUSTOM
    def hasContent_(self):
        if (
            self.STANDARD is not None or
            self.CUSTOM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAssemblyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAssemblyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAssemblyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STANDARD is not None:
            self.STANDARD.export(outfile, level, namespace_, name_='STANDARD', pretty_print=pretty_print)
        if self.CUSTOM is not None:
            self.CUSTOM.export(outfile, level, namespace_, name_='CUSTOM', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STANDARD':
            obj_ = STANDARDType.factory()
            obj_.build(child_)
            self.STANDARD = obj_
            obj_.original_tagname_ = 'STANDARD'
        elif nodeName_ == 'CUSTOM':
            obj_ = CUSTOMType.factory()
            obj_.build(child_)
            self.CUSTOM = obj_
            obj_.original_tagname_ = 'CUSTOM'
# end class ReferenceAssemblyType


class ReferenceSequenceType(GeneratedsSuper):
    """Reference assembly and sequence details."""
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY=None, SEQUENCE=None):
        self.original_tagname_ = None
        self.ASSEMBLY = ASSEMBLY
        if SEQUENCE is None:
            self.SEQUENCE = []
        else:
            self.SEQUENCE = SEQUENCE
    def factory(*args_, **kwargs_):
        if ReferenceSequenceType.subclass:
            return ReferenceSequenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceSequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ASSEMBLY(self): return self.ASSEMBLY
    def set_ASSEMBLY(self, ASSEMBLY): self.ASSEMBLY = ASSEMBLY
    def get_SEQUENCE(self): return self.SEQUENCE
    def set_SEQUENCE(self, SEQUENCE): self.SEQUENCE = SEQUENCE
    def add_SEQUENCE(self, value): self.SEQUENCE.append(value)
    def insert_SEQUENCE_at(self, index, value): self.SEQUENCE.insert(index, value)
    def replace_SEQUENCE_at(self, index, value): self.SEQUENCE[index] = value
    def hasContent_(self):
        if (
            self.ASSEMBLY is not None or
            self.SEQUENCE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceSequenceType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceSequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceSequenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceSequenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceSequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ASSEMBLY is not None:
            self.ASSEMBLY.export(outfile, level, namespace_, name_='ASSEMBLY', pretty_print=pretty_print)
        for SEQUENCE_ in self.SEQUENCE:
            SEQUENCE_.export(outfile, level, namespace_, name_='SEQUENCE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ASSEMBLY':
            obj_ = ReferenceAssemblyType.factory()
            obj_.build(child_)
            self.ASSEMBLY = obj_
            obj_.original_tagname_ = 'ASSEMBLY'
        elif nodeName_ == 'SEQUENCE':
            obj_ = SEQUENCEType.factory()
            obj_.build(child_)
            self.SEQUENCE.append(obj_)
            obj_.original_tagname_ = 'SEQUENCE'
# end class ReferenceSequenceType


class ProcessingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PIPELINE=None, DIRECTIVES=None):
        self.original_tagname_ = None
        self.PIPELINE = PIPELINE
        self.DIRECTIVES = DIRECTIVES
    def factory(*args_, **kwargs_):
        if ProcessingType.subclass:
            return ProcessingType.subclass(*args_, **kwargs_)
        else:
            return ProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PIPELINE(self): return self.PIPELINE
    def set_PIPELINE(self, PIPELINE): self.PIPELINE = PIPELINE
    def get_DIRECTIVES(self): return self.DIRECTIVES
    def set_DIRECTIVES(self, DIRECTIVES): self.DIRECTIVES = DIRECTIVES
    def hasContent_(self):
        if (
            self.PIPELINE is not None or
            self.DIRECTIVES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProcessingType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProcessingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProcessingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PIPELINE is not None:
            self.PIPELINE.export(outfile, level, namespace_, name_='PIPELINE', pretty_print=pretty_print)
        if self.DIRECTIVES is not None:
            self.DIRECTIVES.export(outfile, level, namespace_, name_='DIRECTIVES', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPELINE':
            obj_ = PipelineType.factory()
            obj_.build(child_)
            self.PIPELINE = obj_
            obj_.original_tagname_ = 'PIPELINE'
        elif nodeName_ == 'DIRECTIVES':
            obj_ = SequencingDirectivesType.factory()
            obj_.build(child_)
            self.DIRECTIVES = obj_
            obj_.original_tagname_ = 'DIRECTIVES'
# end class ProcessingType


class CONTACTSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CONTACT=None):
        self.original_tagname_ = None
        if CONTACT is None:
            self.CONTACT = []
        else:
            self.CONTACT = CONTACT
    def factory(*args_, **kwargs_):
        if CONTACTSType.subclass:
            return CONTACTSType.subclass(*args_, **kwargs_)
        else:
            return CONTACTSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CONTACT(self): return self.CONTACT
    def set_CONTACT(self, CONTACT): self.CONTACT = CONTACT
    def add_CONTACT(self, value): self.CONTACT.append(value)
    def insert_CONTACT_at(self, index, value): self.CONTACT.insert(index, value)
    def replace_CONTACT_at(self, index, value): self.CONTACT[index] = value
    def hasContent_(self):
        if (
            self.CONTACT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CONTACTSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CONTACTSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CONTACTSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CONTACTSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CONTACTSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CONTACT_ in self.CONTACT:
            CONTACT_.export(outfile, level, namespace_, name_='CONTACT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CONTACT':
            obj_ = CONTACTType.factory()
            obj_.build(child_)
            self.CONTACT.append(obj_)
            obj_.original_tagname_ = 'CONTACT'
# end class CONTACTSType


class CONTACTType(GeneratedsSuper):
    """Name of contact person for this submission. Internet address of
    person or service to inform on any status changes for this
    submission. Internet address of person or service to inform on
    any errors for this submission."""
    subclass = None
    superclass = None
    def __init__(self, name=None, inform_on_status=None, inform_on_error=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.inform_on_status = _cast(None, inform_on_status)
        self.inform_on_error = _cast(None, inform_on_error)
    def factory(*args_, **kwargs_):
        if CONTACTType.subclass:
            return CONTACTType.subclass(*args_, **kwargs_)
        else:
            return CONTACTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_inform_on_status(self): return self.inform_on_status
    def set_inform_on_status(self, inform_on_status): self.inform_on_status = inform_on_status
    def get_inform_on_error(self): return self.inform_on_error
    def set_inform_on_error(self, inform_on_error): self.inform_on_error = inform_on_error
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CONTACTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CONTACTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CONTACTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CONTACTType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding).decode(), input_name='name'), ))
        if self.inform_on_status is not None and 'inform_on_status' not in already_processed:
            already_processed.add('inform_on_status')
            outfile.write(' inform_on_status=%s' % (self.gds_format_string(quote_attrib(self.inform_on_status).encode(ExternalEncoding).decode(), input_name='inform_on_status'), ))
        if self.inform_on_error is not None and 'inform_on_error' not in already_processed:
            already_processed.add('inform_on_error')
            outfile.write(' inform_on_error=%s' % (self.gds_format_string(quote_attrib(self.inform_on_error).encode(ExternalEncoding).decode(), input_name='inform_on_error'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CONTACTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('inform_on_status', node)
        if value is not None and 'inform_on_status' not in already_processed:
            already_processed.add('inform_on_status')
            self.inform_on_status = value
        value = find_attr_value_('inform_on_error', node)
        if value is not None and 'inform_on_error' not in already_processed:
            already_processed.add('inform_on_error')
            self.inform_on_error = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CONTACTType


class ACTIONSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ACTION=None):
        self.original_tagname_ = None
        if ACTION is None:
            self.ACTION = []
        else:
            self.ACTION = ACTION
    def factory(*args_, **kwargs_):
        if ACTIONSType.subclass:
            return ACTIONSType.subclass(*args_, **kwargs_)
        else:
            return ACTIONSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ACTION(self): return self.ACTION
    def set_ACTION(self, ACTION): self.ACTION = ACTION
    def add_ACTION(self, value): self.ACTION.append(value)
    def insert_ACTION_at(self, index, value): self.ACTION.insert(index, value)
    def replace_ACTION_at(self, index, value): self.ACTION[index] = value
    def hasContent_(self):
        if (
            self.ACTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ACTIONSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ACTIONSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ACTIONSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ACTIONSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ACTIONSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ACTION_ in self.ACTION:
            ACTION_.export(outfile, level, namespace_, name_='ACTION', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ACTION':
            obj_ = ACTIONType.factory()
            obj_.build(child_)
            self.ACTION.append(obj_)
            obj_.original_tagname_ = 'ACTION'
# end class ACTIONSType


class ACTIONType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ADD=None, MODIFY=None, CANCEL=None, SUPPRESS=None, HOLD=None, RELEASE=None, PROTECT=None, VALIDATE=None):
        self.original_tagname_ = None
        self.ADD = ADD
        self.MODIFY = MODIFY
        self.CANCEL = CANCEL
        self.SUPPRESS = SUPPRESS
        self.HOLD = HOLD
        self.RELEASE = RELEASE
        self.PROTECT = PROTECT
        self.VALIDATE = VALIDATE
    def factory(*args_, **kwargs_):
        if ACTIONType.subclass:
            return ACTIONType.subclass(*args_, **kwargs_)
        else:
            return ACTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ADD(self): return self.ADD
    def set_ADD(self, ADD): self.ADD = ADD
    def get_MODIFY(self): return self.MODIFY
    def set_MODIFY(self, MODIFY): self.MODIFY = MODIFY
    def get_CANCEL(self): return self.CANCEL
    def set_CANCEL(self, CANCEL): self.CANCEL = CANCEL
    def get_SUPPRESS(self): return self.SUPPRESS
    def set_SUPPRESS(self, SUPPRESS): self.SUPPRESS = SUPPRESS
    def get_HOLD(self): return self.HOLD
    def set_HOLD(self, HOLD): self.HOLD = HOLD
    def get_RELEASE(self): return self.RELEASE
    def set_RELEASE(self, RELEASE): self.RELEASE = RELEASE
    def get_PROTECT(self): return self.PROTECT
    def set_PROTECT(self, PROTECT): self.PROTECT = PROTECT
    def get_VALIDATE(self): return self.VALIDATE
    def set_VALIDATE(self, VALIDATE): self.VALIDATE = VALIDATE
    def hasContent_(self):
        if (
            self.ADD is not None or
            self.MODIFY is not None or
            self.CANCEL is not None or
            self.SUPPRESS is not None or
            self.HOLD is not None or
            self.RELEASE is not None or
            self.PROTECT is not None or
            self.VALIDATE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ACTIONType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ACTIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ACTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ACTIONType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ACTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ADD is not None:
            self.ADD.export(outfile, level, namespace_, name_='ADD', pretty_print=pretty_print)
        if self.MODIFY is not None:
            self.MODIFY.export(outfile, level, namespace_, name_='MODIFY', pretty_print=pretty_print)
        if self.CANCEL is not None:
            self.CANCEL.export(outfile, level, namespace_, name_='CANCEL', pretty_print=pretty_print)
        if self.SUPPRESS is not None:
            self.SUPPRESS.export(outfile, level, namespace_, name_='SUPPRESS', pretty_print=pretty_print)
        if self.HOLD is not None:
            self.HOLD.export(outfile, level, namespace_, name_='HOLD', pretty_print=pretty_print)
        if self.RELEASE is not None:
            self.RELEASE.export(outfile, level, namespace_, name_='RELEASE', pretty_print=pretty_print)
        if self.PROTECT is not None:
            self.PROTECT.export(outfile, level, namespace_, name_='PROTECT', pretty_print=pretty_print)
        if self.VALIDATE is not None:
            self.VALIDATE.export(outfile, level, namespace_, name_='VALIDATE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ADD':
            obj_ = ADDType.factory()
            obj_.build(child_)
            self.ADD = obj_
            obj_.original_tagname_ = 'ADD'
        elif nodeName_ == 'MODIFY':
            obj_ = MODIFYType.factory()
            obj_.build(child_)
            self.MODIFY = obj_
            obj_.original_tagname_ = 'MODIFY'
        elif nodeName_ == 'CANCEL':
            obj_ = CANCELType.factory()
            obj_.build(child_)
            self.CANCEL = obj_
            obj_.original_tagname_ = 'CANCEL'
        elif nodeName_ == 'SUPPRESS':
            obj_ = SUPPRESSType.factory()
            obj_.build(child_)
            self.SUPPRESS = obj_
            obj_.original_tagname_ = 'SUPPRESS'
        elif nodeName_ == 'HOLD':
            obj_ = HOLDType.factory()
            obj_.build(child_)
            self.HOLD = obj_
            obj_.original_tagname_ = 'HOLD'
        elif nodeName_ == 'RELEASE':
            obj_ = RELEASEType.factory()
            obj_.build(child_)
            self.RELEASE = obj_
            obj_.original_tagname_ = 'RELEASE'
        elif nodeName_ == 'PROTECT':
            obj_ = PROTECTType.factory()
            obj_.build(child_)
            self.PROTECT = obj_
            obj_.original_tagname_ = 'PROTECT'
        elif nodeName_ == 'VALIDATE':
            obj_ = VALIDATEType.factory()
            obj_.build(child_)
            self.VALIDATE = obj_
            obj_.original_tagname_ = 'VALIDATE'
# end class ACTIONType


class ADDType(GeneratedsSuper):
    """Filename or relative path to the XML file being submitted.The type
    of the XML file being submitted."""
    subclass = None
    superclass = None
    def __init__(self, source=None, schema=None):
        self.original_tagname_ = None
        self.source = _cast(None, source)
        self.schema = _cast(None, schema)
    def factory(*args_, **kwargs_):
        if ADDType.subclass:
            return ADDType.subclass(*args_, **kwargs_)
        else:
            return ADDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_schema(self): return self.schema
    def set_schema(self, schema): self.schema = schema
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ADDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ADDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ADDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ADDType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding).decode(), input_name='source'), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            outfile.write(' schema=%s' % (self.gds_format_string(quote_attrib(self.schema).encode(ExternalEncoding).decode(), input_name='schema'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ADDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            self.schema = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ADDType


class MODIFYType(GeneratedsSuper):
    """Filename or relative path to the XML file being updated.The type of
    the XML file being updated."""
    subclass = None
    superclass = None
    def __init__(self, source=None, schema=None):
        self.original_tagname_ = None
        self.source = _cast(None, source)
        self.schema = _cast(None, schema)
    def factory(*args_, **kwargs_):
        if MODIFYType.subclass:
            return MODIFYType.subclass(*args_, **kwargs_)
        else:
            return MODIFYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_schema(self): return self.schema
    def set_schema(self, schema): self.schema = schema
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MODIFYType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MODIFYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MODIFYType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MODIFYType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding).decode(), input_name='source'), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            outfile.write(' schema=%s' % (self.gds_format_string(quote_attrib(self.schema).encode(ExternalEncoding).decode(), input_name='schema'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MODIFYType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            self.schema = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MODIFYType


class CANCELType(GeneratedsSuper):
    """Accession or refname of the object that is being cancelled."""
    subclass = None
    superclass = None
    def __init__(self, target=None):
        self.original_tagname_ = None
        self.target = _cast(None, target)
    def factory(*args_, **kwargs_):
        if CANCELType.subclass:
            return CANCELType.subclass(*args_, **kwargs_)
        else:
            return CANCELType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CANCELType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CANCELType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CANCELType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CANCELType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding).decode(), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CANCELType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CANCELType


class SUPPRESSType(GeneratedsSuper):
    """Accession or refname of the object that is being suppressed."""
    subclass = None
    superclass = None
    def __init__(self, target=None):
        self.original_tagname_ = None
        self.target = _cast(None, target)
    def factory(*args_, **kwargs_):
        if SUPPRESSType.subclass:
            return SUPPRESSType.subclass(*args_, **kwargs_)
        else:
            return SUPPRESSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SUPPRESSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SUPPRESSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SUPPRESSType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SUPPRESSType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding).decode(), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SUPPRESSType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SUPPRESSType


class HOLDType(GeneratedsSuper):
    """Accession or refname of the object that is being made public when
    the hold date expires. If not specified then all objects in the
    submission will be assigned the hold date. The date when the
    submission will be made public."""
    subclass = None
    superclass = None
    def __init__(self, HoldUntilDate=None, target=None):
        self.original_tagname_ = None
        if isinstance(HoldUntilDate, str):
            initvalue_ = datetime_.datetime.strptime(HoldUntilDate, '%Y-%m-%d').date()
        else:
            initvalue_ = HoldUntilDate
        self.HoldUntilDate = initvalue_
        self.target = _cast(None, target)
    def factory(*args_, **kwargs_):
        if HOLDType.subclass:
            return HOLDType.subclass(*args_, **kwargs_)
        else:
            return HOLDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HoldUntilDate(self): return self.HoldUntilDate
    def set_HoldUntilDate(self, HoldUntilDate): self.HoldUntilDate = HoldUntilDate
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HOLDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HOLDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HOLDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HOLDType'):
        if self.HoldUntilDate is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            outfile.write(' HoldUntilDate="%s"' % self.gds_format_date(self.HoldUntilDate, input_name='HoldUntilDate'))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding).decode(), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HOLDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('HoldUntilDate', node)
        if value is not None and 'HoldUntilDate' not in already_processed:
            already_processed.add('HoldUntilDate')
            try:
                self.HoldUntilDate = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (HoldUntilDate): %s' % exp)
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HOLDType


class RELEASEType(GeneratedsSuper):
    """Accession or refname of the object that is made public. If not
    specified then all objects in the submission will made public."""
    subclass = None
    superclass = None
    def __init__(self, target=None):
        self.original_tagname_ = None
        self.target = _cast(None, target)
    def factory(*args_, **kwargs_):
        if RELEASEType.subclass:
            return RELEASEType.subclass(*args_, **kwargs_)
        else:
            return RELEASEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RELEASEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RELEASEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RELEASEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RELEASEType'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding).decode(), input_name='target'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RELEASEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RELEASEType


class PROTECTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if PROTECTType.subclass:
            return PROTECTType.subclass(*args_, **kwargs_)
        else:
            return PROTECTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PROTECTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PROTECTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PROTECTType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PROTECTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PROTECTType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PROTECTType


class VALIDATEType(GeneratedsSuper):
    """Filename or relative path to the XML file being validated.The type
    of the XML file being validated."""
    subclass = None
    superclass = None
    def __init__(self, source=None, schema=None):
        self.original_tagname_ = None
        self.source = _cast(None, source)
        self.schema = _cast(None, schema)
    def factory(*args_, **kwargs_):
        if VALIDATEType.subclass:
            return VALIDATEType.subclass(*args_, **kwargs_)
        else:
            return VALIDATEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_schema(self): return self.schema
    def set_schema(self, schema): self.schema = schema
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VALIDATEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VALIDATEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VALIDATEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VALIDATEType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding).decode(), input_name='source'), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            outfile.write(' schema=%s' % (self.gds_format_string(quote_attrib(self.schema).encode(ExternalEncoding).decode(), input_name='schema'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VALIDATEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.add('schema')
            self.schema = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VALIDATEType


class SUBMISSION_LINKSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SUBMISSION_LINK=None):
        self.original_tagname_ = None
        if SUBMISSION_LINK is None:
            self.SUBMISSION_LINK = []
        else:
            self.SUBMISSION_LINK = SUBMISSION_LINK
    def factory(*args_, **kwargs_):
        if SUBMISSION_LINKSType.subclass:
            return SUBMISSION_LINKSType.subclass(*args_, **kwargs_)
        else:
            return SUBMISSION_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SUBMISSION_LINK(self): return self.SUBMISSION_LINK
    def set_SUBMISSION_LINK(self, SUBMISSION_LINK): self.SUBMISSION_LINK = SUBMISSION_LINK
    def add_SUBMISSION_LINK(self, value): self.SUBMISSION_LINK.append(value)
    def insert_SUBMISSION_LINK_at(self, index, value): self.SUBMISSION_LINK.insert(index, value)
    def replace_SUBMISSION_LINK_at(self, index, value): self.SUBMISSION_LINK[index] = value
    def hasContent_(self):
        if (
            self.SUBMISSION_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SUBMISSION_LINKSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SUBMISSION_LINKSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SUBMISSION_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SUBMISSION_LINKSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SUBMISSION_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SUBMISSION_LINK_ in self.SUBMISSION_LINK:
            SUBMISSION_LINK_.export(outfile, level, namespace_, name_='SUBMISSION_LINK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SUBMISSION_LINK':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.SUBMISSION_LINK.append(obj_)
            obj_.original_tagname_ = 'SUBMISSION_LINK'
# end class SUBMISSION_LINKSType


class SUBMISSION_ATTRIBUTESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SUBMISSION_ATTRIBUTE=None):
        self.original_tagname_ = None
        if SUBMISSION_ATTRIBUTE is None:
            self.SUBMISSION_ATTRIBUTE = []
        else:
            self.SUBMISSION_ATTRIBUTE = SUBMISSION_ATTRIBUTE
    def factory(*args_, **kwargs_):
        if SUBMISSION_ATTRIBUTESType.subclass:
            return SUBMISSION_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return SUBMISSION_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SUBMISSION_ATTRIBUTE(self): return self.SUBMISSION_ATTRIBUTE
    def set_SUBMISSION_ATTRIBUTE(self, SUBMISSION_ATTRIBUTE): self.SUBMISSION_ATTRIBUTE = SUBMISSION_ATTRIBUTE
    def add_SUBMISSION_ATTRIBUTE(self, value): self.SUBMISSION_ATTRIBUTE.append(value)
    def insert_SUBMISSION_ATTRIBUTE_at(self, index, value): self.SUBMISSION_ATTRIBUTE.insert(index, value)
    def replace_SUBMISSION_ATTRIBUTE_at(self, index, value): self.SUBMISSION_ATTRIBUTE[index] = value
    def hasContent_(self):
        if (
            self.SUBMISSION_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SUBMISSION_ATTRIBUTESType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SUBMISSION_ATTRIBUTESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SUBMISSION_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SUBMISSION_ATTRIBUTESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SUBMISSION_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SUBMISSION_ATTRIBUTE_ in self.SUBMISSION_ATTRIBUTE:
            SUBMISSION_ATTRIBUTE_.export(outfile, level, namespace_, name_='SUBMISSION_ATTRIBUTE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SUBMISSION_ATTRIBUTE':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.SUBMISSION_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'SUBMISSION_ATTRIBUTE'
# end class SUBMISSION_ATTRIBUTESType


class URL_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_LINKType.subclass:
            return URL_LINKType.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding).decode(), input_name='URL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_LINKType


class ENTREZ_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, QUERY=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.QUERY = QUERY
        self.LABEL = LABEL
    def factory(*args_, **kwargs_):
        if ENTREZ_LINKType.subclass:
            return ENTREZ_LINKType.subclass(*args_, **kwargs_)
        else:
            return ENTREZ_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_QUERY(self): return self.QUERY
    def set_QUERY(self, QUERY): self.QUERY = QUERY
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def hasContent_(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.QUERY is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTREZ_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTREZ_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTREZ_LINKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding).decode(), input_name='DB'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_integer(self.ID, input_name='ID'), namespace_, eol_))
        if self.QUERY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQUERY>%s</%sQUERY>%s' % (namespace_, self.gds_format_string(quote_xml(self.QUERY).encode(ExternalEncoding).decode(), input_name='QUERY'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'QUERY':
            QUERY_ = child_.text
            QUERY_ = self.gds_validate_string(QUERY_, node, 'QUERY')
            self.QUERY = QUERY_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
# end class ENTREZ_LINKType


class SPOT_DECODE_SPECType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SPOT_LENGTH=None, READ_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_LENGTH = SPOT_LENGTH
        if READ_SPEC is None:
            self.READ_SPEC = []
        else:
            self.READ_SPEC = READ_SPEC
    def factory(*args_, **kwargs_):
        if SPOT_DECODE_SPECType.subclass:
            return SPOT_DECODE_SPECType.subclass(*args_, **kwargs_)
        else:
            return SPOT_DECODE_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPOT_LENGTH(self): return self.SPOT_LENGTH
    def set_SPOT_LENGTH(self, SPOT_LENGTH): self.SPOT_LENGTH = SPOT_LENGTH
    def get_READ_SPEC(self): return self.READ_SPEC
    def set_READ_SPEC(self, READ_SPEC): self.READ_SPEC = READ_SPEC
    def add_READ_SPEC(self, value): self.READ_SPEC.append(value)
    def insert_READ_SPEC_at(self, index, value): self.READ_SPEC.insert(index, value)
    def replace_READ_SPEC_at(self, index, value): self.READ_SPEC[index] = value
    def hasContent_(self):
        if (
            self.SPOT_LENGTH is not None or
            self.READ_SPEC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SPOT_DECODE_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SPOT_DECODE_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SPOT_DECODE_SPECType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_LENGTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPOT_LENGTH>%s</%sSPOT_LENGTH>%s' % (namespace_, self.gds_format_integer(self.SPOT_LENGTH, input_name='SPOT_LENGTH'), namespace_, eol_))
        for READ_SPEC_ in self.READ_SPEC:
            READ_SPEC_.export(outfile, level, namespace_, name_='READ_SPEC', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_LENGTH':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SPOT_LENGTH')
            self.SPOT_LENGTH = ival_
        elif nodeName_ == 'READ_SPEC':
            obj_ = READ_SPECType.factory()
            obj_.build(child_)
            self.READ_SPEC.append(obj_)
            obj_.original_tagname_ = 'READ_SPEC'
# end class SPOT_DECODE_SPECType


class READ_SPECType(GeneratedsSuper):
    """There are various methods to ordering the reads on the spot."""
    subclass = None
    superclass = None
    def __init__(self, READ_INDEX=None, READ_LABEL=None, READ_CLASS=None, READ_TYPE='Forward', RELATIVE_ORDER=None, BASE_COORD=None, EXPECTED_BASECALL_TABLE=None):
        self.original_tagname_ = None
        self.READ_INDEX = READ_INDEX
        self.READ_LABEL = READ_LABEL
        self.READ_CLASS = READ_CLASS
        self.validate_READ_CLASSType(self.READ_CLASS)
        self.READ_TYPE = READ_TYPE
        self.validate_READ_TYPEType(self.READ_TYPE)
        self.RELATIVE_ORDER = RELATIVE_ORDER
        self.BASE_COORD = BASE_COORD
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def factory(*args_, **kwargs_):
        if READ_SPECType.subclass:
            return READ_SPECType.subclass(*args_, **kwargs_)
        else:
            return READ_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_READ_INDEX(self): return self.READ_INDEX
    def set_READ_INDEX(self, READ_INDEX): self.READ_INDEX = READ_INDEX
    def get_READ_LABEL(self): return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL): self.READ_LABEL = READ_LABEL
    def get_READ_CLASS(self): return self.READ_CLASS
    def set_READ_CLASS(self, READ_CLASS): self.READ_CLASS = READ_CLASS
    def get_READ_TYPE(self): return self.READ_TYPE
    def set_READ_TYPE(self, READ_TYPE): self.READ_TYPE = READ_TYPE
    def get_RELATIVE_ORDER(self): return self.RELATIVE_ORDER
    def set_RELATIVE_ORDER(self, RELATIVE_ORDER): self.RELATIVE_ORDER = RELATIVE_ORDER
    def get_BASE_COORD(self): return self.BASE_COORD
    def set_BASE_COORD(self, BASE_COORD): self.BASE_COORD = BASE_COORD
    def get_EXPECTED_BASECALL_TABLE(self): return self.EXPECTED_BASECALL_TABLE
    def set_EXPECTED_BASECALL_TABLE(self, EXPECTED_BASECALL_TABLE): self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def validate_READ_CLASSType(self, value):
        # Validate type READ_CLASSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Application Read', 'Technical Read']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_CLASSType' % {"value" : value.encode("utf-8")} )
    def validate_READ_TYPEType(self, value):
        # Validate type READ_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Forward', 'Reverse', 'Adapter', 'Primer', 'Linker', 'BarCode', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_TYPEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.READ_INDEX is not None or
            self.READ_LABEL is not None or
            self.READ_CLASS is not None or
            self.READ_TYPE != "Forward" or
            self.RELATIVE_ORDER is not None or
            self.BASE_COORD is not None or
            self.EXPECTED_BASECALL_TABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='READ_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='READ_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='READ_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='READ_SPECType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='READ_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.READ_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_INDEX>%s</%sREAD_INDEX>%s' % (namespace_, self.gds_format_integer(self.READ_INDEX, input_name='READ_INDEX'), namespace_, eol_))
        if self.READ_LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_LABEL).encode(ExternalEncoding).decode(), input_name='READ_LABEL'), namespace_, eol_))
        if self.READ_CLASS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_CLASS>%s</%sREAD_CLASS>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_CLASS).encode(ExternalEncoding).decode(), input_name='READ_CLASS'), namespace_, eol_))
        if self.READ_TYPE != "Forward":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_TYPE).encode(ExternalEncoding).decode(), input_name='READ_TYPE'), namespace_, eol_))
        if self.RELATIVE_ORDER is not None:
            self.RELATIVE_ORDER.export(outfile, level, namespace_, name_='RELATIVE_ORDER', pretty_print=pretty_print)
        if self.BASE_COORD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBASE_COORD>%s</%sBASE_COORD>%s' % (namespace_, self.gds_format_integer(self.BASE_COORD, input_name='BASE_COORD'), namespace_, eol_))
        if self.EXPECTED_BASECALL_TABLE is not None:
            self.EXPECTED_BASECALL_TABLE.export(outfile, level, namespace_, name_='EXPECTED_BASECALL_TABLE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'READ_INDEX':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'READ_INDEX')
            self.READ_INDEX = ival_
        elif nodeName_ == 'READ_LABEL':
            READ_LABEL_ = child_.text
            READ_LABEL_ = self.gds_validate_string(READ_LABEL_, node, 'READ_LABEL')
            self.READ_LABEL = READ_LABEL_
        elif nodeName_ == 'READ_CLASS':
            READ_CLASS_ = child_.text
            READ_CLASS_ = self.gds_validate_string(READ_CLASS_, node, 'READ_CLASS')
            self.READ_CLASS = READ_CLASS_
            # validate type READ_CLASSType
            self.validate_READ_CLASSType(self.READ_CLASS)
        elif nodeName_ == 'READ_TYPE':
            READ_TYPE_ = child_.text
            READ_TYPE_ = self.gds_validate_string(READ_TYPE_, node, 'READ_TYPE')
            self.READ_TYPE = READ_TYPE_
            # validate type READ_TYPEType
            self.validate_READ_TYPEType(self.READ_TYPE)
        elif nodeName_ == 'RELATIVE_ORDER':
            obj_ = RELATIVE_ORDERType.factory()
            obj_.build(child_)
            self.RELATIVE_ORDER = obj_
            obj_.original_tagname_ = 'RELATIVE_ORDER'
        elif nodeName_ == 'BASE_COORD':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BASE_COORD')
            self.BASE_COORD = ival_
        elif nodeName_ == 'EXPECTED_BASECALL_TABLE':
            obj_ = EXPECTED_BASECALL_TABLEType.factory()
            obj_.build(child_)
            self.EXPECTED_BASECALL_TABLE = obj_
            obj_.original_tagname_ = 'EXPECTED_BASECALL_TABLE'
# end class READ_SPECType


class RELATIVE_ORDERType(GeneratedsSuper):
    """Specify the read index that precedes this read. Specify the read
    index that follows this read."""
    subclass = None
    superclass = None
    def __init__(self, follows_read_index=None, precedes_read_index=None):
        self.original_tagname_ = None
        self.follows_read_index = _cast(int, follows_read_index)
        self.precedes_read_index = _cast(int, precedes_read_index)
    def factory(*args_, **kwargs_):
        if RELATIVE_ORDERType.subclass:
            return RELATIVE_ORDERType.subclass(*args_, **kwargs_)
        else:
            return RELATIVE_ORDERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_follows_read_index(self): return self.follows_read_index
    def set_follows_read_index(self, follows_read_index): self.follows_read_index = follows_read_index
    def get_precedes_read_index(self): return self.precedes_read_index
    def set_precedes_read_index(self, precedes_read_index): self.precedes_read_index = precedes_read_index
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RELATIVE_ORDERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RELATIVE_ORDERType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RELATIVE_ORDERType'):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            outfile.write(' follows_read_index="%s"' % self.gds_format_integer(self.follows_read_index, input_name='follows_read_index'))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            outfile.write(' precedes_read_index="%s"' % self.gds_format_integer(self.precedes_read_index, input_name='precedes_read_index'))
    def exportChildren(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('follows_read_index', node)
        if value is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            try:
                self.follows_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.follows_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('precedes_read_index', node)
        if value is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            try:
                self.precedes_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.precedes_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RELATIVE_ORDERType


class EXPECTED_BASECALL_TABLEType(GeneratedsSuper):
    """Specify whether the spot should have a default length for this tag
    if the expected base cannot be matched. Specify an optional
    starting point for tag (base offset from 1)."""
    subclass = None
    superclass = None
    def __init__(self, default_length=None, base_coord=None, BASECALL=None):
        self.original_tagname_ = None
        self.default_length = _cast(int, default_length)
        self.base_coord = _cast(int, base_coord)
        if BASECALL is None:
            self.BASECALL = []
        else:
            self.BASECALL = BASECALL
    def factory(*args_, **kwargs_):
        if EXPECTED_BASECALL_TABLEType.subclass:
            return EXPECTED_BASECALL_TABLEType.subclass(*args_, **kwargs_)
        else:
            return EXPECTED_BASECALL_TABLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BASECALL(self): return self.BASECALL
    def set_BASECALL(self, BASECALL): self.BASECALL = BASECALL
    def add_BASECALL(self, value): self.BASECALL.append(value)
    def insert_BASECALL_at(self, index, value): self.BASECALL.insert(index, value)
    def replace_BASECALL_at(self, index, value): self.BASECALL[index] = value
    def get_default_length(self): return self.default_length
    def set_default_length(self, default_length): self.default_length = default_length
    def get_base_coord(self): return self.base_coord
    def set_base_coord(self, base_coord): self.base_coord = base_coord
    def hasContent_(self):
        if (
            self.BASECALL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPECTED_BASECALL_TABLEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPECTED_BASECALL_TABLEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPECTED_BASECALL_TABLEType'):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            outfile.write(' default_length="%s"' % self.gds_format_integer(self.default_length, input_name='default_length'))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            outfile.write(' base_coord="%s"' % self.gds_format_integer(self.base_coord, input_name='base_coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BASECALL_ in self.BASECALL:
            BASECALL_.export(outfile, level, namespace_, name_='BASECALL', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_length', node)
        if value is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            try:
                self.default_length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.default_length < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('base_coord', node)
        if value is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            try:
                self.base_coord = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.base_coord < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BASECALL':
            obj_ = BASECALLType.factory()
            obj_.build(child_)
            self.BASECALL.append(obj_)
            obj_.original_tagname_ = 'BASECALL'
# end class EXPECTED_BASECALL_TABLEType


class BASECALLType(GeneratedsSuper):
    """When match occurs, the read will be tagged with this group
    membership Minimum number of matches to trigger identification.
    Maximum number of mismatches Where the match should occur.
    Changes the rules on how min_match and max_mismatch are counted.
    Only @max_mismatch influences matching process Both matches and
    mismatches are counted. When @max_mismatch is exceeded - it is
    not a match. When @min_match is reached - match is declared.
    Both matches and mismatches are counted. When @max_mismatch is
    exceeded - it is not a match. When @min_match is reached - match
    is declared."""
    subclass = None
    superclass = None
    def __init__(self, max_mismatch=None, min_match=None, match_edge=None, read_group_tag=None, valueOf_=None):
        self.original_tagname_ = None
        self.max_mismatch = _cast(int, max_mismatch)
        self.min_match = _cast(int, min_match)
        self.match_edge = _cast(None, match_edge)
        self.read_group_tag = _cast(None, read_group_tag)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if BASECALLType.subclass:
            return BASECALLType.subclass(*args_, **kwargs_)
        else:
            return BASECALLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max_mismatch(self): return self.max_mismatch
    def set_max_mismatch(self, max_mismatch): self.max_mismatch = max_mismatch
    def get_min_match(self): return self.min_match
    def set_min_match(self, min_match): self.min_match = min_match
    def get_match_edge(self): return self.match_edge
    def set_match_edge(self, match_edge): self.match_edge = match_edge
    def get_read_group_tag(self): return self.read_group_tag
    def set_read_group_tag(self, read_group_tag): self.read_group_tag = read_group_tag
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BASECALLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BASECALLType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding).decode())
            self.exportChildren(outfile, level + 1, namespace_='', name_='BASECALLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BASECALLType'):
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            outfile.write(' max_mismatch="%s"' % self.gds_format_integer(self.max_mismatch, input_name='max_mismatch'))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            outfile.write(' min_match="%s"' % self.gds_format_integer(self.min_match, input_name='min_match'))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            outfile.write(' match_edge=%s' % (self.gds_format_string(quote_attrib(self.match_edge).encode(ExternalEncoding).decode(), input_name='match_edge'), ))
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (self.gds_format_string(quote_attrib(self.read_group_tag).encode(ExternalEncoding).decode(), input_name='read_group_tag'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BASECALLType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_mismatch', node)
        if value is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            try:
                self.max_mismatch = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.max_mismatch < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('min_match', node)
        if value is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            try:
                self.min_match = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.min_match < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('match_edge', node)
        if value is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            self.match_edge = value
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BASECALLType


class LS454Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if LS454Type.subclass:
            return LS454Type.subclass(*args_, **kwargs_)
        else:
            return LS454Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType(self, value):
        # Validate type INSTRUMENT_MODELType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['454 GS', '454 GS 20', '454 GS FLX', '454 GS FLX+', '454 GS FLX Titanium', '454 GS Junior', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LS454Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LS454Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LS454Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LS454Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LS454Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType
            self.validate_INSTRUMENT_MODELType(self.INSTRUMENT_MODEL)
# end class LS454Type


class ILLUMINAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType1(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ILLUMINAType.subclass:
            return ILLUMINAType.subclass(*args_, **kwargs_)
        else:
            return ILLUMINAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType1(self, value):
        # Validate type INSTRUMENT_MODELType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Illumina Genome Analyzer', 'Illumina Genome Analyzer II', 'Illumina Genome Analyzer IIx', 'Illumina HiSeq 2500', 'Illumina HiSeq 2000', 'Illumina HiSeq 1000', 'Illumina MiSeq', 'Illumina HiScanSQ', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType1' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ILLUMINAType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ILLUMINAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ILLUMINAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ILLUMINAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ILLUMINAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType1
            self.validate_INSTRUMENT_MODELType1(self.INSTRUMENT_MODEL)
# end class ILLUMINAType


class HELICOSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType2(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if HELICOSType.subclass:
            return HELICOSType.subclass(*args_, **kwargs_)
        else:
            return HELICOSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType2(self, value):
        # Validate type INSTRUMENT_MODELType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Helicos HeliScope', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType2' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HELICOSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HELICOSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HELICOSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HELICOSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HELICOSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType2
            self.validate_INSTRUMENT_MODELType2(self.INSTRUMENT_MODEL)
# end class HELICOSType


class ABI_SOLIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType3(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ABI_SOLIDType.subclass:
            return ABI_SOLIDType.subclass(*args_, **kwargs_)
        else:
            return ABI_SOLIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType3(self, value):
        # Validate type INSTRUMENT_MODELType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB SOLiD System', 'AB SOLiD System 2.0', 'AB SOLiD System 3.0', 'AB SOLiD 3 Plus System', 'AB SOLiD 4 System', 'AB SOLiD 4hq System', 'AB SOLiD PI System', 'AB 5500 Genetic Analyzer', 'AB 5500xl Genetic Analyzer', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType3' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ABI_SOLIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ABI_SOLIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ABI_SOLIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ABI_SOLIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ABI_SOLIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType3
            self.validate_INSTRUMENT_MODELType3(self.INSTRUMENT_MODEL)
# end class ABI_SOLIDType


class COMPLETE_GENOMICSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType4(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if COMPLETE_GENOMICSType.subclass:
            return COMPLETE_GENOMICSType.subclass(*args_, **kwargs_)
        else:
            return COMPLETE_GENOMICSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType4(self, value):
        # Validate type INSTRUMENT_MODELType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Complete Genomics', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType4' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMPLETE_GENOMICSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMPLETE_GENOMICSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMPLETE_GENOMICSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType4
            self.validate_INSTRUMENT_MODELType4(self.INSTRUMENT_MODEL)
# end class COMPLETE_GENOMICSType


class PACBIO_SMRTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType5(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if PACBIO_SMRTType.subclass:
            return PACBIO_SMRTType.subclass(*args_, **kwargs_)
        else:
            return PACBIO_SMRTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType5(self, value):
        # Validate type INSTRUMENT_MODELType5, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PacBio RS', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType5' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PACBIO_SMRTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PACBIO_SMRTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PACBIO_SMRTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType5
            self.validate_INSTRUMENT_MODELType5(self.INSTRUMENT_MODEL)
# end class PACBIO_SMRTType


class ION_TORRENTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType6(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ION_TORRENTType.subclass:
            return ION_TORRENTType.subclass(*args_, **kwargs_)
        else:
            return ION_TORRENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType6(self, value):
        # Validate type INSTRUMENT_MODELType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Ion Torrent PGM', 'Ion Torrent Proton', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType6' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ION_TORRENTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ION_TORRENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ION_TORRENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ION_TORRENTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ION_TORRENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType6
            self.validate_INSTRUMENT_MODELType6(self.INSTRUMENT_MODEL)
# end class ION_TORRENTType


class CAPILLARYType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType7(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if CAPILLARYType.subclass:
            return CAPILLARYType.subclass(*args_, **kwargs_)
        else:
            return CAPILLARYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_INSTRUMENT_MODELType7(self, value):
        # Validate type INSTRUMENT_MODELType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB 3730xL Genetic Analyzer', 'AB 3730 Genetic Analyzer', 'AB 3500xL Genetic Analyzer', 'AB 3500 Genetic Analyzer', 'AB 3130xL Genetic Analyzer', 'AB 3130 Genetic Analyzer', 'AB 310 Genetic Analyzer', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType7' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CAPILLARYType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CAPILLARYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CAPILLARYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CAPILLARYType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CAPILLARYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType7
            self.validate_INSTRUMENT_MODELType7(self.INSTRUMENT_MODEL)
# end class CAPILLARYType


class PIPE_SECTIONType(GeneratedsSuper):
    """Name of the processing pipeline section."""
    subclass = None
    superclass = None
    def __init__(self, section_name=None, STEP_INDEX=None, PREV_STEP_INDEX=None, PROGRAM=None, VERSION=None, NOTES=None):
        self.original_tagname_ = None
        self.section_name = _cast(None, section_name)
        self.STEP_INDEX = STEP_INDEX
        if PREV_STEP_INDEX is None:
            self.PREV_STEP_INDEX = []
        else:
            self.PREV_STEP_INDEX = PREV_STEP_INDEX
        self.PROGRAM = PROGRAM
        self.VERSION = VERSION
        self.NOTES = NOTES
    def factory(*args_, **kwargs_):
        if PIPE_SECTIONType.subclass:
            return PIPE_SECTIONType.subclass(*args_, **kwargs_)
        else:
            return PIPE_SECTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STEP_INDEX(self): return self.STEP_INDEX
    def set_STEP_INDEX(self, STEP_INDEX): self.STEP_INDEX = STEP_INDEX
    def get_PREV_STEP_INDEX(self): return self.PREV_STEP_INDEX
    def set_PREV_STEP_INDEX(self, PREV_STEP_INDEX): self.PREV_STEP_INDEX = PREV_STEP_INDEX
    def add_PREV_STEP_INDEX(self, value): self.PREV_STEP_INDEX.append(value)
    def insert_PREV_STEP_INDEX_at(self, index, value): self.PREV_STEP_INDEX.insert(index, value)
    def replace_PREV_STEP_INDEX_at(self, index, value): self.PREV_STEP_INDEX[index] = value
    def get_PROGRAM(self): return self.PROGRAM
    def set_PROGRAM(self, PROGRAM): self.PROGRAM = PROGRAM
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_NOTES(self): return self.NOTES
    def set_NOTES(self, NOTES): self.NOTES = NOTES
    def get_section_name(self): return self.section_name
    def set_section_name(self, section_name): self.section_name = section_name
    def hasContent_(self):
        if (
            self.STEP_INDEX is not None or
            self.PREV_STEP_INDEX or
            self.PROGRAM is not None or
            self.VERSION is not None or
            self.NOTES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PIPE_SECTIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PIPE_SECTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PIPE_SECTIONType'):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            outfile.write(' section_name=%s' % (self.gds_format_string(quote_attrib(self.section_name).encode(ExternalEncoding).decode(), input_name='section_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STEP_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTEP_INDEX>%s</%sSTEP_INDEX>%s' % (namespace_, self.gds_format_string(quote_xml(self.STEP_INDEX).encode(ExternalEncoding).decode(), input_name='STEP_INDEX'), namespace_, eol_))
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STEP_INDEX>%s</%sPREV_STEP_INDEX>%s' % (namespace_, self.gds_format_string(quote_xml(PREV_STEP_INDEX_).encode(ExternalEncoding).decode(), input_name='PREV_STEP_INDEX'), namespace_, eol_))
        if self.PROGRAM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespace_, self.gds_format_string(quote_xml(self.PROGRAM).encode(ExternalEncoding).decode(), input_name='PROGRAM'), namespace_, eol_))
        if self.VERSION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespace_, self.gds_format_string(quote_xml(self.VERSION).encode(ExternalEncoding).decode(), input_name='VERSION'), namespace_, eol_))
        if self.NOTES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNOTES>%s</%sNOTES>%s' % (namespace_, self.gds_format_string(quote_xml(self.NOTES).encode(ExternalEncoding).decode(), input_name='NOTES'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('section_name', node)
        if value is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            self.section_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STEP_INDEX':
            STEP_INDEX_ = child_.text
            STEP_INDEX_ = self.gds_validate_string(STEP_INDEX_, node, 'STEP_INDEX')
            self.STEP_INDEX = STEP_INDEX_
        elif nodeName_ == 'PREV_STEP_INDEX':
            PREV_STEP_INDEX_ = child_.text
            PREV_STEP_INDEX_ = self.gds_validate_string(PREV_STEP_INDEX_, node, 'PREV_STEP_INDEX')
            self.PREV_STEP_INDEX.append(PREV_STEP_INDEX_)
        elif nodeName_ == 'PROGRAM':
            PROGRAM_ = child_.text
            PROGRAM_ = self.gds_validate_string(PROGRAM_, node, 'PROGRAM')
            self.PROGRAM = PROGRAM_
        elif nodeName_ == 'VERSION':
            VERSION_ = child_.text
            VERSION_ = self.gds_validate_string(VERSION_, node, 'VERSION')
            self.VERSION = VERSION_
        elif nodeName_ == 'NOTES':
            NOTES_ = child_.text
            NOTES_ = self.gds_validate_string(NOTES_, node, 'NOTES')
            self.NOTES = NOTES_
# end class PIPE_SECTIONType


class STANDARDType(GeneratedsSuper):
    """A recognized name for the genome assembly.Identifies the genome
    assembly using an accession number and a sequence version."""
    subclass = None
    superclass = None
    def __init__(self, refname=None, accession=None):
        self.original_tagname_ = None
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
    def factory(*args_, **kwargs_):
        if STANDARDType.subclass:
            return STANDARDType.subclass(*args_, **kwargs_)
        else:
            return STANDARDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='STANDARDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STANDARDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='STANDARDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STANDARDType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(), input_name='refname'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(), input_name='accession'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='STANDARDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class STANDARDType


class CUSTOMType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DESCRIPTION=None, URL_LINK=None):
        self.original_tagname_ = None
        self.DESCRIPTION = DESCRIPTION
        if URL_LINK is None:
            self.URL_LINK = []
        else:
            self.URL_LINK = URL_LINK
    def factory(*args_, **kwargs_):
        if CUSTOMType.subclass:
            return CUSTOMType.subclass(*args_, **kwargs_)
        else:
            return CUSTOMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_URL_LINK(self): return self.URL_LINK
    def set_URL_LINK(self, URL_LINK): self.URL_LINK = URL_LINK
    def add_URL_LINK(self, value): self.URL_LINK.append(value)
    def insert_URL_LINK_at(self, index, value): self.URL_LINK.insert(index, value)
    def replace_URL_LINK_at(self, index, value): self.URL_LINK[index] = value
    def hasContent_(self):
        if (
            self.DESCRIPTION is not None or
            self.URL_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CUSTOMType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CUSTOMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CUSTOMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CUSTOMType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CUSTOMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespace_, self.gds_format_string(quote_xml(self.DESCRIPTION).encode(ExternalEncoding).decode(), input_name='DESCRIPTION'), namespace_, eol_))
        for URL_LINK_ in self.URL_LINK:
            URL_LINK_.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
        elif nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType8.factory()
            obj_.build(child_)
            self.URL_LINK.append(obj_)
            obj_.original_tagname_ = 'URL_LINK'
# end class CUSTOMType


class URL_LINKType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_LINKType8.subclass:
            return URL_LINKType8.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL_LINKType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding).decode(), input_name='URL'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_LINKType8


class SEQUENCEType(GeneratedsSuper):
    """A recognized name for the reference sequence. Accession.version with
    version being mandatory This is how Reference Sequence is
    labeled in submission file(s). It is equivalent to SQ label in
    BAM. Optional when submitted file uses INSDC accession.version"""
    subclass = None
    superclass = None
    def __init__(self, label=None, refname=None, accession=None):
        self.original_tagname_ = None
        self.label = _cast(None, label)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
    def factory(*args_, **kwargs_):
        if SEQUENCEType.subclass:
            return SEQUENCEType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SEQUENCEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCEType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding).decode(), input_name='label'), ))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(), input_name='refname'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(), input_name='accession'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCEType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SEQUENCEType


GDSClassesMapping = {
    'IDENTIFIERS': IdentifierType,
    'MODIFY': MODIFYType,
    'RELEASE': RELEASEType,
    'CONTACT': CONTACTType,
    'URL_LINK': URL_LINKType8,
    'SUBMISSION_ATTRIBUTES': SUBMISSION_ATTRIBUTESType,
    'PRIMARY_ID': NameType,
    'LS454': LS454Type,
    'SUBMISSION_LINKS': SUBMISSION_LINKSType,
    'ILLUMINA': ILLUMINAType,
    'SUBMISSION_ATTRIBUTE': AttributeType,
    'CUSTOM': CUSTOMType,
    'COMPLETE_GENOMICS': COMPLETE_GENOMICSType,
    'BASECALL': BASECALLType,
    'PIPE_SECTION': PIPE_SECTIONType,
    'ENTREZ_LINK': ENTREZ_LINKType,
    'ACTION': ACTIONType,
    'XREF_LINK': XRefType,
    'CAPILLARY': CAPILLARYType,
    'PROTECT': PROTECTType,
    'ABI_SOLID': ABI_SOLIDType,
    'ASSEMBLY': ReferenceAssemblyType,
    'SEQUENCE': SEQUENCEType,
    'SUPPRESS': SUPPRESSType,
    'STANDARD': STANDARDType,
    'SUBMISSION_LINK': LinkType,
    'ADD': ADDType,
    'SUBMISSION_SET': SubmissionSetType,
    'ION_TORRENT': ION_TORRENTType,
    'CANCEL': CANCELType,
    'SPOT_DECODE_SPEC': SPOT_DECODE_SPECType,
    'VALIDATE': VALIDATEType,
    'HOLD': HOLDType,
    'HELICOS': HELICOSType,
    'UUID': NameType,
    'PIPELINE': PipelineType,
    'EXPECTED_BASECALL_TABLE': EXPECTED_BASECALL_TABLEType,
    'SUBMISSION': SubmissionType,
    'CONTACTS': CONTACTSType,
    'ACTIONS': ACTIONSType,
    'SUBMITTER_ID': QualifiedNameType,
    'SECONDARY_ID': NameType,
    'RELATIVE_ORDER': RELATIVE_ORDERType,
    'DIRECTIVES': SequencingDirectivesType,
    'PACBIO_SMRT': PACBIO_SMRTType,
    'EXTERNAL_ID': QualifiedNameType,
    'READ_SPEC': READ_SPECType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SubmissionType'
        rootClass = SubmissionType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SubmissionType'
        rootClass = SubmissionType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SubmissionType'
        rootClass = SubmissionType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SubmissionType'
        rootClass = SubmissionType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from SRA_submission import *\n\n')
        sys.stdout.write('import SRA_submission as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ABI_SOLIDType",
    "ACTIONSType",
    "ACTIONType",
    "ADDType",
    "AttributeType",
    "BASECALLType",
    "CANCELType",
    "CAPILLARYType",
    "COMPLETE_GENOMICSType",
    "CONTACTSType",
    "CONTACTType",
    "CUSTOMType",
    "ENTREZ_LINKType",
    "EXPECTED_BASECALL_TABLEType",
    "HELICOSType",
    "HOLDType",
    "ILLUMINAType",
    "ION_TORRENTType",
    "IdentifierType",
    "LS454Type",
    "LinkType",
    "MODIFYType",
    "NameType",
    "PACBIO_SMRTType",
    "PIPE_SECTIONType",
    "PROTECTType",
    "PipelineType",
    "PlatformType",
    "ProcessingType",
    "QualifiedNameType",
    "READ_SPECType",
    "RELATIVE_ORDERType",
    "RELEASEType",
    "ReferenceAssemblyType",
    "ReferenceSequenceType",
    "SEQUENCEType",
    "SPOT_DECODE_SPECType",
    "STANDARDType",
    "SUBMISSION_ATTRIBUTESType",
    "SUBMISSION_LINKSType",
    "SUPPRESSType",
    "SequencingDirectivesType",
    "SpotDescriptorType",
    "SubmissionSetType",
    "SubmissionType",
    "URLType",
    "URL_LINKType",
    "URL_LINKType8",
    "VALIDATEType",
    "XRefType"
]
