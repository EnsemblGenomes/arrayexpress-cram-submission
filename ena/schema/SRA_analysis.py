#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 27 16:22:57 2015 by generateDS.py version 2.17a.
#
# Command line options:
#   ('-o', 'SRA_analysis.py')
#   ('-s', 'SRA_analysis_sub.py')
#
# Command line arguments:
#   SRA.analysis.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -o "SRA_analysis.py" -s "SRA_analysis_sub.py" SRA.analysis.xsd
#
# Current working directory (os.getcwd()):
#   sra-xml1.5_15July
#

import base64
import datetime as datetime_
import re as re_
import sys
import warnings as warnings_

from lxml import etree as etree_

Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')

        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def gds_format_string(self, input_data, input_name=''):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)

        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data

        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values

        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')

        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values

        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data

        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values

        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()

        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0',):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds,)
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r'\{.*\}')

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            return None

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)


#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name,))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline,)
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                        self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                        self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))

    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                      self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                      self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class AnalysisFileType(GeneratedsSuper):
    """The file name. The type of the file. A tab delimited text file that
    can be viewed as a spreadsheet. The first line should contain
    column headers. Binary form of the Sequence alignment/map format
    for read placements, from the SAM tools project. See
    http://sourceforge.net/projects/samtools/ Index sorted alignment
    for fast random access.See
    http://sourceforge.net/projects/samtools/ The checksum method.
    Checksum generated by the MD5 method (md5sum in unix). The file
    checksum.The checksum of the unencrypted file (used in
    conjunction with the checksum of an encrypted file)."""
    subclass = None
    superclass = None

    def __init__(self, checksum_method=None, checksum=None, filetype=None, unencrypted_checksum=None, filename=None,
                 CHECKLIST=None):
        self.original_tagname_ = None
        self.checksum_method = _cast(None, checksum_method)
        self.checksum = _cast(None, checksum)
        self.filetype = _cast(None, filetype)
        self.unencrypted_checksum = _cast(None, unencrypted_checksum)
        self.filename = _cast(None, filename)
        self.CHECKLIST = CHECKLIST

    def factory(*args_, **kwargs_):
        if AnalysisFileType.subclass:
            return AnalysisFileType.subclass(*args_, **kwargs_)
        else:
            return AnalysisFileType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_CHECKLIST(self):
        return self.CHECKLIST

    def set_CHECKLIST(self, CHECKLIST):
        self.CHECKLIST = CHECKLIST

    def get_checksum_method(self):
        return self.checksum_method

    def set_checksum_method(self, checksum_method):
        self.checksum_method = checksum_method

    def get_checksum(self):
        return self.checksum

    def set_checksum(self, checksum):
        self.checksum = checksum

    def get_filetype(self):
        return self.filetype

    def set_filetype(self, filetype):
        self.filetype = filetype

    def get_unencrypted_checksum(self):
        return self.unencrypted_checksum

    def set_unencrypted_checksum(self, unencrypted_checksum):
        self.unencrypted_checksum = unencrypted_checksum

    def get_filename(self):
        return self.filename

    def set_filename(self, filename):
        self.filename = filename

    def hasContent_(self):
        if (
                    self.CHECKLIST is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='AnalysisFileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnalysisFileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnalysisFileType'):
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            outfile.write(' checksum_method=%s' % (
            self.gds_format_string(quote_attrib(self.checksum_method).encode(ExternalEncoding).decode(),
                                   input_name='checksum_method'),))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (
            self.gds_format_string(quote_attrib(self.checksum).encode(ExternalEncoding).decode(),
                                   input_name='checksum'),))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            outfile.write(' filetype=%s' % (
            self.gds_format_string(quote_attrib(self.filetype).encode(ExternalEncoding).decode(),
                                   input_name='filetype'),))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            outfile.write(' unencrypted_checksum=%s' % (
            self.gds_format_string(quote_attrib(self.unencrypted_checksum).encode(ExternalEncoding).decode(),
                                   input_name='unencrypted_checksum'),))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (
            self.gds_format_string(quote_attrib(self.filename).encode(ExternalEncoding).decode(),
                                   input_name='filename'),))

    def exportChildren(self, outfile, level, namespace_='', name_='AnalysisFileType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CHECKLIST is not None:
            self.CHECKLIST.export(outfile, level, namespace_, name_='CHECKLIST', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('checksum_method', node)
        if value is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            self.checksum_method = value
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('filetype', node)
        if value is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            self.filetype = value
        value = find_attr_value_('unencrypted_checksum', node)
        if value is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            self.unencrypted_checksum = value
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CHECKLIST':
            obj_ = CHECKLISTType.factory()
            obj_.build(child_)
            self.CHECKLIST = obj_
            obj_.original_tagname_ = 'CHECKLIST'


# end class AnalysisFileType


class AnalysisSetType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, ANALYSIS=None):
        self.original_tagname_ = None
        if ANALYSIS is None:
            self.ANALYSIS = []
        else:
            self.ANALYSIS = ANALYSIS

    def factory(*args_, **kwargs_):
        if AnalysisSetType.subclass:
            return AnalysisSetType.subclass(*args_, **kwargs_)
        else:
            return AnalysisSetType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ANALYSIS(self):
        return self.ANALYSIS

    def set_ANALYSIS(self, ANALYSIS):
        self.ANALYSIS = ANALYSIS

    def add_ANALYSIS(self, value):
        self.ANALYSIS.append(value)

    def insert_ANALYSIS_at(self, index, value):
        self.ANALYSIS.insert(index, value)

    def replace_ANALYSIS_at(self, index, value):
        self.ANALYSIS[index] = value

    def hasContent_(self):
        if (
                self.ANALYSIS
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='AnalysisSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnalysisSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnalysisSetType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='AnalysisSetType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_ in self.ANALYSIS:
            ANALYSIS_.export(outfile, level, namespace_, name_='ANALYSIS', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ANALYSIS':
            obj_ = AnalysisType.factory()
            obj_.build(child_)
            self.ANALYSIS.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS'


# end class AnalysisSetType


class AnalysisType(GeneratedsSuper):
    """A SRA analysis object captures sequence analysis results including
    sequence alignments, sequence variations and sequence
    annotations. If applicable, the center name of the institution
    responsible for this analysis. The date when this analysis was
    produced."""
    subclass = None
    superclass = None

    def __init__(self, broker_name=None, alias=None, center_name=None, analysis_date=None, accession=None,
                 analysis_center=None, IDENTIFIERS=None, TITLE=None, DESCRIPTION=None, STUDY_REF=None, SAMPLE_REF=None,
                 RUN_REF=None, ANALYSIS_REF=None, ANALYSIS_TYPE=None, FILES=None, ANALYSIS_LINKS=None,
                 ANALYSIS_ATTRIBUTES=None):
        self.original_tagname_ = None
        self.broker_name = _cast(None, broker_name)
        self.alias = _cast(None, alias)
        self.center_name = _cast(None, center_name)
        if isinstance(analysis_date, str):
            initvalue_ = datetime_.datetime.strptime(analysis_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = analysis_date
        self.analysis_date = initvalue_
        self.accession = _cast(None, accession)
        self.analysis_center = _cast(None, analysis_center)
        self.IDENTIFIERS = IDENTIFIERS
        self.TITLE = TITLE
        self.DESCRIPTION = DESCRIPTION
        self.STUDY_REF = STUDY_REF
        if SAMPLE_REF is None:
            self.SAMPLE_REF = []
        else:
            self.SAMPLE_REF = SAMPLE_REF
        if RUN_REF is None:
            self.RUN_REF = []
        else:
            self.RUN_REF = RUN_REF
        if ANALYSIS_REF is None:
            self.ANALYSIS_REF = []
        else:
            self.ANALYSIS_REF = ANALYSIS_REF
        self.ANALYSIS_TYPE = ANALYSIS_TYPE
        self.FILES = FILES
        self.ANALYSIS_LINKS = ANALYSIS_LINKS
        self.ANALYSIS_ATTRIBUTES = ANALYSIS_ATTRIBUTES

    def factory(*args_, **kwargs_):
        if AnalysisType.subclass:
            return AnalysisType.subclass(*args_, **kwargs_)
        else:
            return AnalysisType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS

    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS

    def get_TITLE(self):
        return self.TITLE

    def set_TITLE(self, TITLE):
        self.TITLE = TITLE

    def get_DESCRIPTION(self):
        return self.DESCRIPTION

    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION

    def get_STUDY_REF(self):
        return self.STUDY_REF

    def set_STUDY_REF(self, STUDY_REF):
        self.STUDY_REF = STUDY_REF

    def get_SAMPLE_REF(self):
        return self.SAMPLE_REF

    def set_SAMPLE_REF(self, SAMPLE_REF):
        self.SAMPLE_REF = SAMPLE_REF

    def add_SAMPLE_REF(self, value):
        self.SAMPLE_REF.append(value)

    def insert_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF.insert(index, value)

    def replace_SAMPLE_REF_at(self, index, value):
        self.SAMPLE_REF[index] = value

    def get_RUN_REF(self):
        return self.RUN_REF

    def set_RUN_REF(self, RUN_REF):
        self.RUN_REF = RUN_REF

    def add_RUN_REF(self, value):
        self.RUN_REF.append(value)

    def insert_RUN_REF_at(self, index, value):
        self.RUN_REF.insert(index, value)

    def replace_RUN_REF_at(self, index, value):
        self.RUN_REF[index] = value

    def get_ANALYSIS_REF(self):
        return self.ANALYSIS_REF

    def set_ANALYSIS_REF(self, ANALYSIS_REF):
        self.ANALYSIS_REF = ANALYSIS_REF

    def add_ANALYSIS_REF(self, value):
        self.ANALYSIS_REF.append(value)

    def insert_ANALYSIS_REF_at(self, index, value):
        self.ANALYSIS_REF.insert(index, value)

    def replace_ANALYSIS_REF_at(self, index, value):
        self.ANALYSIS_REF[index] = value

    def get_ANALYSIS_TYPE(self):
        return self.ANALYSIS_TYPE

    def set_ANALYSIS_TYPE(self, ANALYSIS_TYPE):
        self.ANALYSIS_TYPE = ANALYSIS_TYPE

    def get_FILES(self):
        return self.FILES

    def set_FILES(self, FILES):
        self.FILES = FILES

    def get_ANALYSIS_LINKS(self):
        return self.ANALYSIS_LINKS

    def set_ANALYSIS_LINKS(self, ANALYSIS_LINKS):
        self.ANALYSIS_LINKS = ANALYSIS_LINKS

    def get_ANALYSIS_ATTRIBUTES(self):
        return self.ANALYSIS_ATTRIBUTES

    def set_ANALYSIS_ATTRIBUTES(self, ANALYSIS_ATTRIBUTES):
        self.ANALYSIS_ATTRIBUTES = ANALYSIS_ATTRIBUTES

    def get_broker_name(self):
        return self.broker_name

    def set_broker_name(self, broker_name):
        self.broker_name = broker_name

    def get_alias(self):
        return self.alias

    def set_alias(self, alias):
        self.alias = alias

    def get_center_name(self):
        return self.center_name

    def set_center_name(self, center_name):
        self.center_name = center_name

    def get_analysis_date(self):
        return self.analysis_date

    def set_analysis_date(self, analysis_date):
        self.analysis_date = analysis_date

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def get_analysis_center(self):
        return self.analysis_center

    def set_analysis_center(self, analysis_center):
        self.analysis_center = analysis_center

    def hasContent_(self):
        if (
                                                            self.IDENTIFIERS is not None or
                                                            self.TITLE is not None or
                                                        self.DESCRIPTION is not None or
                                                    self.STUDY_REF is not None or
                                            self.SAMPLE_REF or
                                        self.RUN_REF or
                                    self.ANALYSIS_REF or
                                    self.ANALYSIS_TYPE is not None or
                                self.FILES is not None or
                            self.ANALYSIS_LINKS is not None or
                        self.ANALYSIS_ATTRIBUTES is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='AnalysisType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnalysisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnalysisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnalysisType'):
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            outfile.write(' broker_name=%s' % (
            self.gds_format_string(quote_attrib(self.broker_name).encode(ExternalEncoding).decode(),
                                   input_name='broker_name'),))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (
            self.gds_format_string(quote_attrib(self.alias).encode(ExternalEncoding).decode(), input_name='alias'),))
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            outfile.write(' center_name=%s' % (
            self.gds_format_string(quote_attrib(self.center_name).encode(ExternalEncoding).decode(),
                                   input_name='center_name'),))
        if self.analysis_date is not None and 'analysis_date' not in already_processed:
            already_processed.add('analysis_date')
            outfile.write(
                ' analysis_date="%s"' % self.gds_format_datetime(self.analysis_date, input_name='analysis_date'))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))
        if self.analysis_center is not None and 'analysis_center' not in already_processed:
            already_processed.add('analysis_center')
            outfile.write(' analysis_center=%s' % (
            self.gds_format_string(quote_attrib(self.analysis_center).encode(ExternalEncoding).decode(),
                                   input_name='analysis_center'),))

    def exportChildren(self, outfile, level, namespace_='', name_='AnalysisType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)
        if self.TITLE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.TITLE).encode(ExternalEncoding).decode(), input_name='TITLE'), namespace_, eol_))
        if self.DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.DESCRIPTION).encode(ExternalEncoding).decode(), input_name='DESCRIPTION'), namespace_,
                                                                   eol_))
        if self.STUDY_REF is not None:
            self.STUDY_REF.export(outfile, level, namespace_, name_='STUDY_REF', pretty_print=pretty_print)
        for SAMPLE_REF_ in self.SAMPLE_REF:
            SAMPLE_REF_.export(outfile, level, namespace_, name_='SAMPLE_REF', pretty_print=pretty_print)
        for RUN_REF_ in self.RUN_REF:
            RUN_REF_.export(outfile, level, namespace_, name_='RUN_REF', pretty_print=pretty_print)
        for ANALYSIS_REF_ in self.ANALYSIS_REF:
            ANALYSIS_REF_.export(outfile, level, namespace_, name_='ANALYSIS_REF', pretty_print=pretty_print)
        if self.ANALYSIS_TYPE is not None:
            self.ANALYSIS_TYPE.export(outfile, level, namespace_, name_='ANALYSIS_TYPE', pretty_print=pretty_print)
        if self.FILES is not None:
            self.FILES.export(outfile, level, namespace_, name_='FILES', pretty_print=pretty_print)
        if self.ANALYSIS_LINKS is not None:
            self.ANALYSIS_LINKS.export(outfile, level, namespace_, name_='ANALYSIS_LINKS', pretty_print=pretty_print)
        if self.ANALYSIS_ATTRIBUTES is not None:
            self.ANALYSIS_ATTRIBUTES.export(outfile, level, namespace_, name_='ANALYSIS_ATTRIBUTES',
                                            pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('broker_name', node)
        if value is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            self.broker_name = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('center_name', node)
        if value is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            self.center_name = value
        value = find_attr_value_('analysis_date', node)
        if value is not None and 'analysis_date' not in already_processed:
            already_processed.add('analysis_date')
            try:
                self.analysis_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (analysis_date): %s' % exp)
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('analysis_center', node)
        if value is not None and 'analysis_center' not in already_processed:
            already_processed.add('analysis_center')
            self.analysis_center = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
        elif nodeName_ == 'TITLE':
            TITLE_ = child_.text
            TITLE_ = self.gds_validate_string(TITLE_, node, 'TITLE')
            self.TITLE = TITLE_
        elif nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType.factory()
            obj_.build(child_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'SAMPLE_REF':
            obj_ = SAMPLE_REFType.factory()
            obj_.build(child_)
            self.SAMPLE_REF.append(obj_)
            obj_.original_tagname_ = 'SAMPLE_REF'
        elif nodeName_ == 'RUN_REF':
            obj_ = RUN_REFType.factory()
            obj_.build(child_)
            self.RUN_REF.append(obj_)
            obj_.original_tagname_ = 'RUN_REF'
        elif nodeName_ == 'ANALYSIS_REF':
            obj_ = ANALYSIS_REFType.factory()
            obj_.build(child_)
            self.ANALYSIS_REF.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_REF'
        elif nodeName_ == 'ANALYSIS_TYPE':
            obj_ = ANALYSIS_TYPEType.factory()
            obj_.build(child_)
            self.ANALYSIS_TYPE = obj_
            obj_.original_tagname_ = 'ANALYSIS_TYPE'
        elif nodeName_ == 'FILES':
            obj_ = FILESType.factory()
            obj_.build(child_)
            self.FILES = obj_
            obj_.original_tagname_ = 'FILES'
        elif nodeName_ == 'ANALYSIS_LINKS':
            obj_ = ANALYSIS_LINKSType.factory()
            obj_.build(child_)
            self.ANALYSIS_LINKS = obj_
            obj_.original_tagname_ = 'ANALYSIS_LINKS'
        elif nodeName_ == 'ANALYSIS_ATTRIBUTES':
            obj_ = ANALYSIS_ATTRIBUTESType.factory()
            obj_.build(child_)
            self.ANALYSIS_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'ANALYSIS_ATTRIBUTES'


# end class AnalysisType


class NameType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                self.valueOf_
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='NameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding).decode())
            self.exportChildren(outfile, level + 1, namespace_='', name_='NameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='NameType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class NameType


class QualifiedNameType(NameType):
    """A string value that constrains the domain of named identifiers
    (namespace)."""
    subclass = None
    superclass = NameType

    def __init__(self, namespace=None, valueOf_=None):
        self.original_tagname_ = None
        super(QualifiedNameType, self).__init__(valueOf_, )
        self.namespace = _cast(None, namespace)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if QualifiedNameType.subclass:
            return QualifiedNameType.subclass(*args_, **kwargs_)
        else:
            return QualifiedNameType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_namespace(self):
        return self.namespace

    def set_namespace(self, namespace):
        self.namespace = namespace

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                    self.valueOf_ or
                    super(QualifiedNameType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='QualifiedNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding).decode())
            self.exportChildren(outfile, level + 1, namespace_='', name_='QualifiedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QualifiedNameType'):
        super(QualifiedNameType, self).exportAttributes(outfile, level, already_processed, namespace_,
                                                        name_='QualifiedNameType')
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (
            self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding).decode(),
                                   input_name='namespace'),))

    def exportChildren(self, outfile, level, namespace_='', name_='QualifiedNameType', fromsubclass_=False,
                       pretty_print=True):
        super(QualifiedNameType, self).exportChildren(outfile, level, namespace_, name_, True,
                                                      pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        super(QualifiedNameType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class QualifiedNameType


class IdentifierType(GeneratedsSuper):
    """Set of record identifiers."""
    subclass = None
    superclass = None

    def __init__(self, PRIMARY_ID=None, SECONDARY_ID=None, EXTERNAL_ID=None, SUBMITTER_ID=None, UUID=None):
        self.original_tagname_ = None
        self.PRIMARY_ID = PRIMARY_ID
        if SECONDARY_ID is None:
            self.SECONDARY_ID = []
        else:
            self.SECONDARY_ID = SECONDARY_ID
        if EXTERNAL_ID is None:
            self.EXTERNAL_ID = []
        else:
            self.EXTERNAL_ID = EXTERNAL_ID
        self.SUBMITTER_ID = SUBMITTER_ID
        if UUID is None:
            self.UUID = []
        else:
            self.UUID = UUID

    def factory(*args_, **kwargs_):
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_PRIMARY_ID(self):
        return self.PRIMARY_ID

    def set_PRIMARY_ID(self, PRIMARY_ID):
        self.PRIMARY_ID = PRIMARY_ID

    def get_SECONDARY_ID(self):
        return self.SECONDARY_ID

    def set_SECONDARY_ID(self, SECONDARY_ID):
        self.SECONDARY_ID = SECONDARY_ID

    def add_SECONDARY_ID(self, value):
        self.SECONDARY_ID.append(value)

    def insert_SECONDARY_ID_at(self, index, value):
        self.SECONDARY_ID.insert(index, value)

    def replace_SECONDARY_ID_at(self, index, value):
        self.SECONDARY_ID[index] = value

    def get_EXTERNAL_ID(self):
        return self.EXTERNAL_ID

    def set_EXTERNAL_ID(self, EXTERNAL_ID):
        self.EXTERNAL_ID = EXTERNAL_ID

    def add_EXTERNAL_ID(self, value):
        self.EXTERNAL_ID.append(value)

    def insert_EXTERNAL_ID_at(self, index, value):
        self.EXTERNAL_ID.insert(index, value)

    def replace_EXTERNAL_ID_at(self, index, value):
        self.EXTERNAL_ID[index] = value

    def get_SUBMITTER_ID(self):
        return self.SUBMITTER_ID

    def set_SUBMITTER_ID(self, SUBMITTER_ID):
        self.SUBMITTER_ID = SUBMITTER_ID

    def get_UUID(self):
        return self.UUID

    def set_UUID(self, UUID):
        self.UUID = UUID

    def add_UUID(self, value):
        self.UUID.append(value)

    def insert_UUID_at(self, index, value):
        self.UUID.insert(index, value)

    def replace_UUID_at(self, index, value):
        self.UUID[index] = value

    def hasContent_(self):
        if (
                                    self.PRIMARY_ID is not None or
                                self.SECONDARY_ID or
                            self.EXTERNAL_ID or
                            self.SUBMITTER_ID is not None or
                    self.UUID
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='IdentifierType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PRIMARY_ID is not None:
            self.PRIMARY_ID.export(outfile, level, namespace_, name_='PRIMARY_ID', pretty_print=pretty_print)
        for SECONDARY_ID_ in self.SECONDARY_ID:
            SECONDARY_ID_.export(outfile, level, namespace_, name_='SECONDARY_ID', pretty_print=pretty_print)
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            EXTERNAL_ID_.export(outfile, level, namespace_, name_='EXTERNAL_ID', pretty_print=pretty_print)
        if self.SUBMITTER_ID is not None:
            self.SUBMITTER_ID.export(outfile, level, namespace_, name_='SUBMITTER_ID', pretty_print=pretty_print)
        for UUID_ in self.UUID:
            UUID_.export(outfile, level, namespace_, name_='UUID', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PRIMARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PRIMARY_ID = obj_
            obj_.original_tagname_ = 'PRIMARY_ID'
        elif nodeName_ == 'SECONDARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SECONDARY_ID.append(obj_)
            obj_.original_tagname_ = 'SECONDARY_ID'
        elif nodeName_ == 'EXTERNAL_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.EXTERNAL_ID.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_ID'
        elif nodeName_ == 'SUBMITTER_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.SUBMITTER_ID = obj_
            obj_.original_tagname_ = 'SUBMITTER_ID'
        elif nodeName_ == 'UUID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.UUID.append(obj_)
            obj_.original_tagname_ = 'UUID'


# end class IdentifierType


class XRefType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, DB=None, ID=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.LABEL = LABEL

    def factory(*args_, **kwargs_):
        if XRefType.subclass:
            return XRefType.subclass(*args_, **kwargs_)
        else:
            return XRefType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_DB(self):
        return self.DB

    def set_DB(self, DB):
        self.DB = DB

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def hasContent_(self):
        if (
                            self.DB is not None or
                            self.ID is not None or
                        self.LABEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='XRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='XRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XRefType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='XRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding).decode(), input_name='DB'),
            namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding).decode(), input_name='ID'),
            namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_


# end class XRefType


class URLType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL

    def factory(*args_, **kwargs_):
        if URLType.subclass:
            return URLType.subclass(*args_, **kwargs_)
        else:
            return URLType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_URL(self):
        return self.URL

    def set_URL(self, URL):
        self.URL = URL

    def hasContent_(self):
        if (
                        self.LABEL is not None or
                        self.URL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='URLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='URLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding).decode(), input_name='URL'),
            namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_


# end class URLType


class AttributeType(GeneratedsSuper):
    """Reusable attributes to encode tag-value pairs with optional units."""
    subclass = None
    superclass = None

    def __init__(self, TAG=None, VALUE=None, UNITS=None):
        self.original_tagname_ = None
        self.TAG = TAG
        self.VALUE = VALUE
        self.UNITS = UNITS

    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_TAG(self):
        return self.TAG

    def set_TAG(self, TAG):
        self.TAG = TAG

    def get_VALUE(self):
        return self.VALUE

    def set_VALUE(self, VALUE):
        self.VALUE = VALUE

    def get_UNITS(self):
        return self.UNITS

    def set_UNITS(self, UNITS):
        self.UNITS = UNITS

    def hasContent_(self):
        if (
                            self.TAG is not None or
                            self.VALUE is not None or
                        self.UNITS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='AttributeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAG>%s</%sTAG>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.TAG).encode(ExternalEncoding).decode(), input_name='TAG'),
            namespace_, eol_))
        if self.VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.VALUE).encode(ExternalEncoding).decode(), input_name='VALUE'), namespace_, eol_))
        if self.UNITS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNITS>%s</%sUNITS>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.UNITS).encode(ExternalEncoding).decode(), input_name='UNITS'), namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TAG':
            TAG_ = child_.text
            TAG_ = self.gds_validate_string(TAG_, node, 'TAG')
            self.TAG = TAG_
        elif nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE = VALUE_
        elif nodeName_ == 'UNITS':
            UNITS_ = child_.text
            UNITS_ = self.gds_validate_string(UNITS_, node, 'UNITS')
            self.UNITS = UNITS_


# end class AttributeType


class LinkType(GeneratedsSuper):
    """Reusable external links type to encode URL links, Entrez links, and
    db_xref links."""
    subclass = None
    superclass = None

    def __init__(self, URL_LINK=None, XREF_LINK=None, ENTREZ_LINK=None):
        self.original_tagname_ = None
        self.URL_LINK = URL_LINK
        self.XREF_LINK = XREF_LINK
        self.ENTREZ_LINK = ENTREZ_LINK

    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_URL_LINK(self):
        return self.URL_LINK

    def set_URL_LINK(self, URL_LINK):
        self.URL_LINK = URL_LINK

    def get_XREF_LINK(self):
        return self.XREF_LINK

    def set_XREF_LINK(self, XREF_LINK):
        self.XREF_LINK = XREF_LINK

    def get_ENTREZ_LINK(self):
        return self.ENTREZ_LINK

    def set_ENTREZ_LINK(self, ENTREZ_LINK):
        self.ENTREZ_LINK = ENTREZ_LINK

    def hasContent_(self):
        if (
                            self.URL_LINK is not None or
                            self.XREF_LINK is not None or
                        self.ENTREZ_LINK is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL_LINK is not None:
            self.URL_LINK.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
        if self.XREF_LINK is not None:
            self.XREF_LINK.export(outfile, level, namespace_, name_='XREF_LINK', pretty_print=pretty_print)
        if self.ENTREZ_LINK is not None:
            self.ENTREZ_LINK.export(outfile, level, namespace_, name_='ENTREZ_LINK', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType.factory()
            obj_.build(child_)
            self.URL_LINK = obj_
            obj_.original_tagname_ = 'URL_LINK'
        elif nodeName_ == 'XREF_LINK':
            obj_ = XRefType.factory()
            obj_.build(child_)
            self.XREF_LINK = obj_
            obj_.original_tagname_ = 'XREF_LINK'
        elif nodeName_ == 'ENTREZ_LINK':
            obj_ = ENTREZ_LINKType.factory()
            obj_.build(child_)
            self.ENTREZ_LINK = obj_
            obj_.original_tagname_ = 'ENTREZ_LINK'


# end class LinkType


class SpotDescriptorType(GeneratedsSuper):
    """The SPOT_DESCRIPTOR specifies how to decode the individual reads of
    interest from the monolithic spot sequence. The spot descriptor
    contains aspects of the experimental design, platform, and
    processing information. There will be two methods of
    specification: one will be an index into a table of typical
    decodings, the other being an exact specification."""
    subclass = None
    superclass = None

    def __init__(self, SPOT_DECODE_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC

    def factory(*args_, **kwargs_):
        if SpotDescriptorType.subclass:
            return SpotDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SpotDescriptorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_SPOT_DECODE_SPEC(self):
        return self.SPOT_DECODE_SPEC

    def set_SPOT_DECODE_SPEC(self, SPOT_DECODE_SPEC):
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC

    def hasContent_(self):
        if (
                    self.SPOT_DECODE_SPEC is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SpotDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpotDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpotDescriptorType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpotDescriptorType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='SpotDescriptorType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_DECODE_SPEC is not None:
            self.SPOT_DECODE_SPEC.export(outfile, level, namespace_, name_='SPOT_DECODE_SPEC',
                                         pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_DECODE_SPEC':
            obj_ = SPOT_DECODE_SPECType.factory()
            obj_.build(child_)
            self.SPOT_DECODE_SPEC = obj_
            obj_.original_tagname_ = 'SPOT_DECODE_SPEC'


# end class SpotDescriptorType


class PlatformType(GeneratedsSuper):
    """The PLATFORM specifies the sequencing platform."""
    subclass = None
    superclass = None

    def __init__(self, LS454=None, ILLUMINA=None, HELICOS=None, ABI_SOLID=None, COMPLETE_GENOMICS=None,
                 PACBIO_SMRT=None, ION_TORRENT=None, CAPILLARY=None):
        self.original_tagname_ = None
        self.LS454 = LS454
        self.ILLUMINA = ILLUMINA
        self.HELICOS = HELICOS
        self.ABI_SOLID = ABI_SOLID
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
        self.PACBIO_SMRT = PACBIO_SMRT
        self.ION_TORRENT = ION_TORRENT
        self.CAPILLARY = CAPILLARY

    def factory(*args_, **kwargs_):
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_LS454(self):
        return self.LS454

    def set_LS454(self, LS454):
        self.LS454 = LS454

    def get_ILLUMINA(self):
        return self.ILLUMINA

    def set_ILLUMINA(self, ILLUMINA):
        self.ILLUMINA = ILLUMINA

    def get_HELICOS(self):
        return self.HELICOS

    def set_HELICOS(self, HELICOS):
        self.HELICOS = HELICOS

    def get_ABI_SOLID(self):
        return self.ABI_SOLID

    def set_ABI_SOLID(self, ABI_SOLID):
        self.ABI_SOLID = ABI_SOLID

    def get_COMPLETE_GENOMICS(self):
        return self.COMPLETE_GENOMICS

    def set_COMPLETE_GENOMICS(self, COMPLETE_GENOMICS):
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS

    def get_PACBIO_SMRT(self):
        return self.PACBIO_SMRT

    def set_PACBIO_SMRT(self, PACBIO_SMRT):
        self.PACBIO_SMRT = PACBIO_SMRT

    def get_ION_TORRENT(self):
        return self.ION_TORRENT

    def set_ION_TORRENT(self, ION_TORRENT):
        self.ION_TORRENT = ION_TORRENT

    def get_CAPILLARY(self):
        return self.CAPILLARY

    def set_CAPILLARY(self, CAPILLARY):
        self.CAPILLARY = CAPILLARY

    def hasContent_(self):
        if (
                                                self.LS454 is not None or
                                                self.ILLUMINA is not None or
                                            self.HELICOS is not None or
                                        self.ABI_SOLID is not None or
                                    self.COMPLETE_GENOMICS is not None or
                                self.PACBIO_SMRT is not None or
                            self.ION_TORRENT is not None or
                        self.CAPILLARY is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='PlatformType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='PlatformType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LS454 is not None:
            self.LS454.export(outfile, level, namespace_, name_='LS454', pretty_print=pretty_print)
        if self.ILLUMINA is not None:
            self.ILLUMINA.export(outfile, level, namespace_, name_='ILLUMINA', pretty_print=pretty_print)
        if self.HELICOS is not None:
            self.HELICOS.export(outfile, level, namespace_, name_='HELICOS', pretty_print=pretty_print)
        if self.ABI_SOLID is not None:
            self.ABI_SOLID.export(outfile, level, namespace_, name_='ABI_SOLID', pretty_print=pretty_print)
        if self.COMPLETE_GENOMICS is not None:
            self.COMPLETE_GENOMICS.export(outfile, level, namespace_, name_='COMPLETE_GENOMICS',
                                          pretty_print=pretty_print)
        if self.PACBIO_SMRT is not None:
            self.PACBIO_SMRT.export(outfile, level, namespace_, name_='PACBIO_SMRT', pretty_print=pretty_print)
        if self.ION_TORRENT is not None:
            self.ION_TORRENT.export(outfile, level, namespace_, name_='ION_TORRENT', pretty_print=pretty_print)
        if self.CAPILLARY is not None:
            self.CAPILLARY.export(outfile, level, namespace_, name_='CAPILLARY', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LS454':
            obj_ = LS454Type.factory()
            obj_.build(child_)
            self.LS454 = obj_
            obj_.original_tagname_ = 'LS454'
        elif nodeName_ == 'ILLUMINA':
            obj_ = ILLUMINAType.factory()
            obj_.build(child_)
            self.ILLUMINA = obj_
            obj_.original_tagname_ = 'ILLUMINA'
        elif nodeName_ == 'HELICOS':
            obj_ = HELICOSType.factory()
            obj_.build(child_)
            self.HELICOS = obj_
            obj_.original_tagname_ = 'HELICOS'
        elif nodeName_ == 'ABI_SOLID':
            obj_ = ABI_SOLIDType.factory()
            obj_.build(child_)
            self.ABI_SOLID = obj_
            obj_.original_tagname_ = 'ABI_SOLID'
        elif nodeName_ == 'COMPLETE_GENOMICS':
            obj_ = COMPLETE_GENOMICSType.factory()
            obj_.build(child_)
            self.COMPLETE_GENOMICS = obj_
            obj_.original_tagname_ = 'COMPLETE_GENOMICS'
        elif nodeName_ == 'PACBIO_SMRT':
            obj_ = PACBIO_SMRTType.factory()
            obj_.build(child_)
            self.PACBIO_SMRT = obj_
            obj_.original_tagname_ = 'PACBIO_SMRT'
        elif nodeName_ == 'ION_TORRENT':
            obj_ = ION_TORRENTType.factory()
            obj_.build(child_)
            self.ION_TORRENT = obj_
            obj_.original_tagname_ = 'ION_TORRENT'
        elif nodeName_ == 'CAPILLARY':
            obj_ = CAPILLARYType.factory()
            obj_.build(child_)
            self.CAPILLARY = obj_
            obj_.original_tagname_ = 'CAPILLARY'


# end class PlatformType


class SequencingDirectivesType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, SAMPLE_DEMUX_DIRECTIVE=None):
        self.original_tagname_ = None
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
        self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)

    def factory(*args_, **kwargs_):
        if SequencingDirectivesType.subclass:
            return SequencingDirectivesType.subclass(*args_, **kwargs_)
        else:
            return SequencingDirectivesType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_SAMPLE_DEMUX_DIRECTIVE(self):
        return self.SAMPLE_DEMUX_DIRECTIVE

    def set_SAMPLE_DEMUX_DIRECTIVE(self, SAMPLE_DEMUX_DIRECTIVE):
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE

    def validate_SAMPLE_DEMUX_DIRECTIVEType(self, value):
        # Validate type SAMPLE_DEMUX_DIRECTIVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['leave_as_pool', 'submitter_demultiplexed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on SAMPLE_DEMUX_DIRECTIVEType' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.SAMPLE_DEMUX_DIRECTIVE is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SequencingDirectivesType', namespacedef_='',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequencingDirectivesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequencingDirectivesType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequencingDirectivesType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='SequencingDirectivesType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSAMPLE_DEMUX_DIRECTIVE>%s</%sSAMPLE_DEMUX_DIRECTIVE>%s' % (namespace_,
                                                                                         self.gds_format_string(
                                                                                             quote_xml(
                                                                                                 self.SAMPLE_DEMUX_DIRECTIVE).encode(
                                                                                                 ExternalEncoding).decode(),
                                                                                             input_name='SAMPLE_DEMUX_DIRECTIVE'),
                                                                                         namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SAMPLE_DEMUX_DIRECTIVE':
            SAMPLE_DEMUX_DIRECTIVE_ = child_.text
            SAMPLE_DEMUX_DIRECTIVE_ = self.gds_validate_string(SAMPLE_DEMUX_DIRECTIVE_, node, 'SAMPLE_DEMUX_DIRECTIVE')
            self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE_
            # validate type SAMPLE_DEMUX_DIRECTIVEType
            self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)


# end class SequencingDirectivesType


class PipelineType(GeneratedsSuper):
    """The PipelineType identifies the sequence or tree of actions to
    process the sequencing data."""
    subclass = None
    superclass = None

    def __init__(self, PIPE_SECTION=None):
        self.original_tagname_ = None
        if PIPE_SECTION is None:
            self.PIPE_SECTION = []
        else:
            self.PIPE_SECTION = PIPE_SECTION

    def factory(*args_, **kwargs_):
        if PipelineType.subclass:
            return PipelineType.subclass(*args_, **kwargs_)
        else:
            return PipelineType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_PIPE_SECTION(self):
        return self.PIPE_SECTION

    def set_PIPE_SECTION(self, PIPE_SECTION):
        self.PIPE_SECTION = PIPE_SECTION

    def add_PIPE_SECTION(self, value):
        self.PIPE_SECTION.append(value)

    def insert_PIPE_SECTION_at(self, index, value):
        self.PIPE_SECTION.insert(index, value)

    def replace_PIPE_SECTION_at(self, index, value):
        self.PIPE_SECTION[index] = value

    def hasContent_(self):
        if (
                self.PIPE_SECTION
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='PipelineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PipelineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PipelineType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='PipelineType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PIPE_SECTION_ in self.PIPE_SECTION:
            PIPE_SECTION_.export(outfile, level, namespace_, name_='PIPE_SECTION', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPE_SECTION':
            obj_ = PIPE_SECTIONType.factory()
            obj_.build(child_)
            self.PIPE_SECTION.append(obj_)
            obj_.original_tagname_ = 'PIPE_SECTION'


# end class PipelineType


class ReferenceAssemblyType(GeneratedsSuper):
    """Reference assembly details."""
    subclass = None
    superclass = None

    def __init__(self, STANDARD=None, CUSTOM=None):
        self.original_tagname_ = None
        self.STANDARD = STANDARD
        self.CUSTOM = CUSTOM

    def factory(*args_, **kwargs_):
        if ReferenceAssemblyType.subclass:
            return ReferenceAssemblyType.subclass(*args_, **kwargs_)
        else:
            return ReferenceAssemblyType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_STANDARD(self):
        return self.STANDARD

    def set_STANDARD(self, STANDARD):
        self.STANDARD = STANDARD

    def get_CUSTOM(self):
        return self.CUSTOM

    def set_CUSTOM(self, CUSTOM):
        self.CUSTOM = CUSTOM

    def hasContent_(self):
        if (
                        self.STANDARD is not None or
                        self.CUSTOM is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAssemblyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAssemblyType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAssemblyType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STANDARD is not None:
            self.STANDARD.export(outfile, level, namespace_, name_='STANDARD', pretty_print=pretty_print)
        if self.CUSTOM is not None:
            self.CUSTOM.export(outfile, level, namespace_, name_='CUSTOM', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STANDARD':
            obj_ = STANDARDType.factory()
            obj_.build(child_)
            self.STANDARD = obj_
            obj_.original_tagname_ = 'STANDARD'
        elif nodeName_ == 'CUSTOM':
            obj_ = CUSTOMType.factory()
            obj_.build(child_)
            self.CUSTOM = obj_
            obj_.original_tagname_ = 'CUSTOM'


# end class ReferenceAssemblyType


class ReferenceSequenceType(GeneratedsSuper):
    """Reference assembly and sequence details."""
    subclass = None
    superclass = None

    def __init__(self, ASSEMBLY=None, SEQUENCE=None, extensiontype_=None):
        self.original_tagname_ = None
        self.ASSEMBLY = ASSEMBLY
        if SEQUENCE is None:
            self.SEQUENCE = []
        else:
            self.SEQUENCE = SEQUENCE
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if ReferenceSequenceType.subclass:
            return ReferenceSequenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceSequenceType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ASSEMBLY(self):
        return self.ASSEMBLY

    def set_ASSEMBLY(self, ASSEMBLY):
        self.ASSEMBLY = ASSEMBLY

    def get_SEQUENCE(self):
        return self.SEQUENCE

    def set_SEQUENCE(self, SEQUENCE):
        self.SEQUENCE = SEQUENCE

    def add_SEQUENCE(self, value):
        self.SEQUENCE.append(value)

    def insert_SEQUENCE_at(self, index, value):
        self.SEQUENCE.insert(index, value)

    def replace_SEQUENCE_at(self, index, value):
        self.SEQUENCE[index] = value

    def get_extensiontype_(self):
        return self.extensiontype_

    def set_extensiontype_(self, extensiontype_):
        self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
                        self.ASSEMBLY is not None or
                    self.SEQUENCE
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ReferenceSequenceType',
               namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceSequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceSequenceType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceSequenceType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceSequenceType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ASSEMBLY is not None:
            self.ASSEMBLY.export(outfile, level, namespace_, name_='ASSEMBLY', pretty_print=pretty_print)
        for SEQUENCE_ in self.SEQUENCE:
            SEQUENCE_.export(outfile, level, namespace_, name_='SEQUENCE', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ASSEMBLY':
            obj_ = ReferenceAssemblyType.factory()
            obj_.build(child_)
            self.ASSEMBLY = obj_
            obj_.original_tagname_ = 'ASSEMBLY'
        elif nodeName_ == 'SEQUENCE':
            obj_ = SEQUENCEType.factory()
            obj_.build(child_)
            self.SEQUENCE.append(obj_)
            obj_.original_tagname_ = 'SEQUENCE'


# end class ReferenceSequenceType


class ProcessingType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, PIPELINE=None, DIRECTIVES=None):
        self.original_tagname_ = None
        self.PIPELINE = PIPELINE
        self.DIRECTIVES = DIRECTIVES

    def factory(*args_, **kwargs_):
        if ProcessingType.subclass:
            return ProcessingType.subclass(*args_, **kwargs_)
        else:
            return ProcessingType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_PIPELINE(self):
        return self.PIPELINE

    def set_PIPELINE(self, PIPELINE):
        self.PIPELINE = PIPELINE

    def get_DIRECTIVES(self):
        return self.DIRECTIVES

    def set_DIRECTIVES(self, DIRECTIVES):
        self.DIRECTIVES = DIRECTIVES

    def hasContent_(self):
        if (
                        self.PIPELINE is not None or
                        self.DIRECTIVES is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ProcessingType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProcessingType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ProcessingType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PIPELINE is not None:
            self.PIPELINE.export(outfile, level, namespace_, name_='PIPELINE', pretty_print=pretty_print)
        if self.DIRECTIVES is not None:
            self.DIRECTIVES.export(outfile, level, namespace_, name_='DIRECTIVES', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPELINE':
            obj_ = PipelineType.factory()
            obj_.build(child_)
            self.PIPELINE = obj_
            obj_.original_tagname_ = 'PIPELINE'
        elif nodeName_ == 'DIRECTIVES':
            obj_ = SequencingDirectivesType.factory()
            obj_.build(child_)
            self.DIRECTIVES = obj_
            obj_.original_tagname_ = 'DIRECTIVES'


# end class ProcessingType


class CHECKLISTType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, center_name=None, alias=None, broker_name=None, accession=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        self.center_name = _cast(None, center_name)
        self.alias = _cast(None, alias)
        self.broker_name = _cast(None, broker_name)
        self.accession = _cast(None, accession)
        self.IDENTIFIERS = IDENTIFIERS

    def factory(*args_, **kwargs_):
        if CHECKLISTType.subclass:
            return CHECKLISTType.subclass(*args_, **kwargs_)
        else:
            return CHECKLISTType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS

    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS

    def get_center_name(self):
        return self.center_name

    def set_center_name(self, center_name):
        self.center_name = center_name

    def get_alias(self):
        return self.alias

    def set_alias(self, alias):
        self.alias = alias

    def get_broker_name(self):
        return self.broker_name

    def set_broker_name(self, broker_name):
        self.broker_name = broker_name

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def hasContent_(self):
        if (
                    self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='CHECKLISTType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CHECKLISTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CHECKLISTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CHECKLISTType'):
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            outfile.write(' center_name=%s' % (
            self.gds_format_string(quote_attrib(self.center_name).encode(ExternalEncoding).decode(),
                                   input_name='center_name'),))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (
            self.gds_format_string(quote_attrib(self.alias).encode(ExternalEncoding).decode(), input_name='alias'),))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            outfile.write(' broker_name=%s' % (
            self.gds_format_string(quote_attrib(self.broker_name).encode(ExternalEncoding).decode(),
                                   input_name='broker_name'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))

    def exportChildren(self, outfile, level, namespace_='', name_='CHECKLISTType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('center_name', node)
        if value is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            self.center_name = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('broker_name', node)
        if value is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            self.broker_name = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'


# end class CHECKLISTType


class STUDY_REFType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, refcenter=None, accession=None, refname=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        self.refcenter = _cast(None, refcenter)
        self.accession = _cast(None, accession)
        self.refname = _cast(None, refname)
        self.IDENTIFIERS = IDENTIFIERS

    def factory(*args_, **kwargs_):
        if STUDY_REFType.subclass:
            return STUDY_REFType.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS

    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS

    def get_refcenter(self):
        return self.refcenter

    def set_refcenter(self, refcenter):
        self.refcenter = refcenter

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def get_refname(self):
        return self.refname

    def set_refname(self, refname):
        self.refname = refname

    def hasContent_(self):
        if (
                    self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='STUDY_REFType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STUDY_REFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='STUDY_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STUDY_REFType'):
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (
            self.gds_format_string(quote_attrib(self.refcenter).encode(ExternalEncoding).decode(),
                                   input_name='refcenter'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (
            self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(),
                                   input_name='refname'),))

    def exportChildren(self, outfile, level, namespace_='', name_='STUDY_REFType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'


# end class STUDY_REFType


class SAMPLE_REFType(GeneratedsSuper):
    """A label associating the sample with BAM (@RG/ID or @RG/SM) or VCF
    file samples."""
    subclass = None
    superclass = None

    def __init__(self, refcenter=None, refname=None, accession=None, label=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        self.refcenter = _cast(None, refcenter)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
        self.label = _cast(None, label)
        self.IDENTIFIERS = IDENTIFIERS

    def factory(*args_, **kwargs_):
        if SAMPLE_REFType.subclass:
            return SAMPLE_REFType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_REFType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS

    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS

    def get_refcenter(self):
        return self.refcenter

    def set_refcenter(self, refcenter):
        self.refcenter = refcenter

    def get_refname(self):
        return self.refname

    def set_refname(self, refname):
        self.refname = refname

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def hasContent_(self):
        if (
                    self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SAMPLE_REFType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SAMPLE_REFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SAMPLE_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SAMPLE_REFType'):
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (
            self.gds_format_string(quote_attrib(self.refcenter).encode(ExternalEncoding).decode(),
                                   input_name='refcenter'),))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (
            self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(),
                                   input_name='refname'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (
            self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding).decode(), input_name='label'),))

    def exportChildren(self, outfile, level, namespace_='', name_='SAMPLE_REFType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'


# end class SAMPLE_REFType


class RUN_REFType(GeneratedsSuper):
    """A label associating the run with BAM (@RG/ID)."""
    subclass = None
    superclass = None

    def __init__(self, refcenter=None, refname=None, accession=None, label=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        self.refcenter = _cast(None, refcenter)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
        self.label = _cast(None, label)
        self.IDENTIFIERS = IDENTIFIERS

    def factory(*args_, **kwargs_):
        if RUN_REFType.subclass:
            return RUN_REFType.subclass(*args_, **kwargs_)
        else:
            return RUN_REFType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS

    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS

    def get_refcenter(self):
        return self.refcenter

    def set_refcenter(self, refcenter):
        self.refcenter = refcenter

    def get_refname(self):
        return self.refname

    def set_refname(self, refname):
        self.refname = refname

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def hasContent_(self):
        if (
                    self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='RUN_REFType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RUN_REFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RUN_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RUN_REFType'):
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (
            self.gds_format_string(quote_attrib(self.refcenter).encode(ExternalEncoding).decode(),
                                   input_name='refcenter'),))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (
            self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(),
                                   input_name='refname'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (
            self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding).decode(), input_name='label'),))

    def exportChildren(self, outfile, level, namespace_='', name_='RUN_REFType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'


# end class RUN_REFType


class ANALYSIS_REFType(GeneratedsSuper):
    """A label associating the run with BAM (@RG/ID)."""
    subclass = None
    superclass = None

    def __init__(self, refcenter=None, refname=None, accession=None, label=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        self.refcenter = _cast(None, refcenter)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
        self.label = _cast(None, label)
        self.IDENTIFIERS = IDENTIFIERS

    def factory(*args_, **kwargs_):
        if ANALYSIS_REFType.subclass:
            return ANALYSIS_REFType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_REFType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_IDENTIFIERS(self):
        return self.IDENTIFIERS

    def set_IDENTIFIERS(self, IDENTIFIERS):
        self.IDENTIFIERS = IDENTIFIERS

    def get_refcenter(self):
        return self.refcenter

    def set_refcenter(self, refcenter):
        self.refcenter = refcenter

    def get_refname(self):
        return self.refname

    def set_refname(self, refname):
        self.refname = refname

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def hasContent_(self):
        if (
                    self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ANALYSIS_REFType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANALYSIS_REFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ANALYSIS_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANALYSIS_REFType'):
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (
            self.gds_format_string(quote_attrib(self.refcenter).encode(ExternalEncoding).decode(),
                                   input_name='refcenter'),))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (
            self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(),
                                   input_name='refname'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (
            self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding).decode(), input_name='label'),))

    def exportChildren(self, outfile, level, namespace_='', name_='ANALYSIS_REFType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'


# end class ANALYSIS_REFType


class ANALYSIS_TYPEType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, REFERENCE_ALIGNMENT=None, SEQUENCE_VARIATION=None, SEQUENCE_ASSEMBLY=None,
                 SEQUENCE_ANNOTATION=None, REFERENCE_SEQUENCE=None, SAMPLE_PHENOTYPE=None):
        self.original_tagname_ = None
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
        self.SEQUENCE_VARIATION = SEQUENCE_VARIATION
        self.SEQUENCE_ASSEMBLY = SEQUENCE_ASSEMBLY
        self.SEQUENCE_ANNOTATION = SEQUENCE_ANNOTATION
        self.REFERENCE_SEQUENCE = REFERENCE_SEQUENCE
        self.SAMPLE_PHENOTYPE = SAMPLE_PHENOTYPE

    def factory(*args_, **kwargs_):
        if ANALYSIS_TYPEType.subclass:
            return ANALYSIS_TYPEType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_TYPEType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_REFERENCE_ALIGNMENT(self):
        return self.REFERENCE_ALIGNMENT

    def set_REFERENCE_ALIGNMENT(self, REFERENCE_ALIGNMENT):
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT

    def get_SEQUENCE_VARIATION(self):
        return self.SEQUENCE_VARIATION

    def set_SEQUENCE_VARIATION(self, SEQUENCE_VARIATION):
        self.SEQUENCE_VARIATION = SEQUENCE_VARIATION

    def get_SEQUENCE_ASSEMBLY(self):
        return self.SEQUENCE_ASSEMBLY

    def set_SEQUENCE_ASSEMBLY(self, SEQUENCE_ASSEMBLY):
        self.SEQUENCE_ASSEMBLY = SEQUENCE_ASSEMBLY

    def get_SEQUENCE_ANNOTATION(self):
        return self.SEQUENCE_ANNOTATION

    def set_SEQUENCE_ANNOTATION(self, SEQUENCE_ANNOTATION):
        self.SEQUENCE_ANNOTATION = SEQUENCE_ANNOTATION

    def get_REFERENCE_SEQUENCE(self):
        return self.REFERENCE_SEQUENCE

    def set_REFERENCE_SEQUENCE(self, REFERENCE_SEQUENCE):
        self.REFERENCE_SEQUENCE = REFERENCE_SEQUENCE

    def get_SAMPLE_PHENOTYPE(self):
        return self.SAMPLE_PHENOTYPE

    def set_SAMPLE_PHENOTYPE(self, SAMPLE_PHENOTYPE):
        self.SAMPLE_PHENOTYPE = SAMPLE_PHENOTYPE

    def hasContent_(self):
        if (
                                        self.REFERENCE_ALIGNMENT is not None or
                                        self.SEQUENCE_VARIATION is not None or
                                    self.SEQUENCE_ASSEMBLY is not None or
                                self.SEQUENCE_ANNOTATION is not None or
                            self.REFERENCE_SEQUENCE is not None or
                        self.SAMPLE_PHENOTYPE is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ANALYSIS_TYPEType', namespacedef_=' xmlns:com="SRA.common" ',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANALYSIS_TYPEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ANALYSIS_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANALYSIS_TYPEType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ANALYSIS_TYPEType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.REFERENCE_ALIGNMENT is not None:
            self.REFERENCE_ALIGNMENT.export(outfile, level, namespace_, name_='REFERENCE_ALIGNMENT',
                                            pretty_print=pretty_print)
        if self.SEQUENCE_VARIATION is not None:
            self.SEQUENCE_VARIATION.export(outfile, level, namespace_, name_='SEQUENCE_VARIATION',
                                           pretty_print=pretty_print)
        if self.SEQUENCE_ASSEMBLY is not None:
            self.SEQUENCE_ASSEMBLY.export(outfile, level, namespace_, name_='SEQUENCE_ASSEMBLY',
                                          pretty_print=pretty_print)
        if self.SEQUENCE_ANNOTATION is not None:
            self.SEQUENCE_ANNOTATION.export(outfile, level, namespace_, name_='SEQUENCE_ANNOTATION',
                                            pretty_print=pretty_print)
        if self.REFERENCE_SEQUENCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREFERENCE_SEQUENCE>%s</%sREFERENCE_SEQUENCE>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.REFERENCE_SEQUENCE).encode(ExternalEncoding).decode(), input_name='REFERENCE_SEQUENCE'),
                                                                                 namespace_, eol_))
        if self.SAMPLE_PHENOTYPE is not None:
            self.SAMPLE_PHENOTYPE.export(outfile, level, namespace_, name_='SAMPLE_PHENOTYPE',
                                         pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'REFERENCE_ALIGNMENT':
            class_obj_ = self.get_class_obj_(child_, ReferenceSequenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.REFERENCE_ALIGNMENT = obj_
            obj_.original_tagname_ = 'REFERENCE_ALIGNMENT'
        elif nodeName_ == 'SEQUENCE_VARIATION':
            obj_ = SEQUENCE_VARIATIONType.factory()
            obj_.build(child_)
            self.SEQUENCE_VARIATION = obj_
            obj_.original_tagname_ = 'SEQUENCE_VARIATION'
        elif nodeName_ == 'SEQUENCE_ASSEMBLY':
            obj_ = SEQUENCE_ASSEMBLYType.factory()
            obj_.build(child_)
            self.SEQUENCE_ASSEMBLY = obj_
            obj_.original_tagname_ = 'SEQUENCE_ASSEMBLY'
        elif nodeName_ == 'SEQUENCE_ANNOTATION':
            obj_ = SEQUENCE_ANNOTATIONType.factory()
            obj_.build(child_)
            self.SEQUENCE_ANNOTATION = obj_
            obj_.original_tagname_ = 'SEQUENCE_ANNOTATION'
        elif nodeName_ == 'REFERENCE_SEQUENCE':
            REFERENCE_SEQUENCE_ = child_.text
            REFERENCE_SEQUENCE_ = self.gds_validate_string(REFERENCE_SEQUENCE_, node, 'REFERENCE_SEQUENCE')
            self.REFERENCE_SEQUENCE = REFERENCE_SEQUENCE_
        elif nodeName_ == 'SAMPLE_PHENOTYPE':
            obj_ = SAMPLE_PHENOTYPEType.factory()
            obj_.build(child_)
            self.SAMPLE_PHENOTYPE = obj_
            obj_.original_tagname_ = 'SAMPLE_PHENOTYPE'


# end class ANALYSIS_TYPEType


class REFERENCE_SEQUENCE(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self):
        self.original_tagname_ = None

    def factory(*args_, **kwargs_):
        if REFERENCE_SEQUENCE.subclass:
            return REFERENCE_SEQUENCE.subclass(*args_, **kwargs_)
        else:
            return REFERENCE_SEQUENCE(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='REFERENCE_SEQUENCE', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='REFERENCE_SEQUENCE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='REFERENCE_SEQUENCE',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='REFERENCE_SEQUENCE'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='REFERENCE_SEQUENCE', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class REFERENCE_SEQUENCE


class SEQUENCE_VARIATIONType(ReferenceSequenceType):
    subclass = None
    superclass = ReferenceSequenceType

    def __init__(self, ASSEMBLY=None, SEQUENCE=None, EXPERIMENT_TYPE=None, PROGRAM=None, PLATFORM=None,
                 IMPUTATION=None):
        self.original_tagname_ = None
        super(SEQUENCE_VARIATIONType, self).__init__(ASSEMBLY, SEQUENCE, )
        if EXPERIMENT_TYPE is None:
            self.EXPERIMENT_TYPE = []
        else:
            self.EXPERIMENT_TYPE = EXPERIMENT_TYPE
        self.PROGRAM = PROGRAM
        self.PLATFORM = PLATFORM
        self.IMPUTATION = IMPUTATION

    def factory(*args_, **kwargs_):
        if SEQUENCE_VARIATIONType.subclass:
            return SEQUENCE_VARIATIONType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCE_VARIATIONType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_EXPERIMENT_TYPE(self):
        return self.EXPERIMENT_TYPE

    def set_EXPERIMENT_TYPE(self, EXPERIMENT_TYPE):
        self.EXPERIMENT_TYPE = EXPERIMENT_TYPE

    def add_EXPERIMENT_TYPE(self, value):
        self.EXPERIMENT_TYPE.append(value)

    def insert_EXPERIMENT_TYPE_at(self, index, value):
        self.EXPERIMENT_TYPE.insert(index, value)

    def replace_EXPERIMENT_TYPE_at(self, index, value):
        self.EXPERIMENT_TYPE[index] = value

    def get_PROGRAM(self):
        return self.PROGRAM

    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM

    def get_PLATFORM(self):
        return self.PLATFORM

    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM

    def get_IMPUTATION(self):
        return self.IMPUTATION

    def set_IMPUTATION(self, IMPUTATION):
        self.IMPUTATION = IMPUTATION

    def validate_EXPERIMENT_TYPEType(self, value):
        # Validate type EXPERIMENT_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Whole genome sequencing', 'Exome sequencing', 'Genotyping by array', 'Curation']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on EXPERIMENT_TYPEType' % {
                    "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                                self.EXPERIMENT_TYPE or
                                    self.PROGRAM is not None or
                                self.PLATFORM is not None or
                            self.IMPUTATION is not None or
                    super(SEQUENCE_VARIATIONType, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SEQUENCE_VARIATIONType', namespacedef_='',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCE_VARIATIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCE_VARIATIONType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCE_VARIATIONType'):
        super(SEQUENCE_VARIATIONType, self).exportAttributes(outfile, level, already_processed, namespace_,
                                                             name_='SEQUENCE_VARIATIONType')

    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCE_VARIATIONType', fromsubclass_=False,
                       pretty_print=True):
        super(SEQUENCE_VARIATIONType, self).exportChildren(outfile, level, namespace_, name_, True,
                                                           pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_TYPE_ in self.EXPERIMENT_TYPE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXPERIMENT_TYPE>%s</%sEXPERIMENT_TYPE>%s' % (namespace_, self.gds_format_string(
                quote_xml(EXPERIMENT_TYPE_).encode(ExternalEncoding).decode(), input_name='EXPERIMENT_TYPE'),
                                                                           namespace_, eol_))
        if self.PROGRAM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.PROGRAM).encode(ExternalEncoding).decode(), input_name='PROGRAM'), namespace_, eol_))
        if self.PLATFORM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLATFORM>%s</%sPLATFORM>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.PLATFORM).encode(ExternalEncoding).decode(), input_name='PLATFORM'), namespace_, eol_))
        if self.IMPUTATION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIMPUTATION>%s</%sIMPUTATION>%s' % (
            namespace_, self.gds_format_boolean(self.IMPUTATION, input_name='IMPUTATION'), namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(SEQUENCE_VARIATIONType, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EXPERIMENT_TYPE':
            EXPERIMENT_TYPE_ = child_.text
            EXPERIMENT_TYPE_ = self.gds_validate_string(EXPERIMENT_TYPE_, node, 'EXPERIMENT_TYPE')
            self.EXPERIMENT_TYPE.append(EXPERIMENT_TYPE_)
            # validate type EXPERIMENT_TYPEType
            self.validate_EXPERIMENT_TYPEType(self.EXPERIMENT_TYPE[-1])
        elif nodeName_ == 'PROGRAM':
            PROGRAM_ = child_.text
            PROGRAM_ = self.gds_validate_string(PROGRAM_, node, 'PROGRAM')
            self.PROGRAM = PROGRAM_
        elif nodeName_ == 'PLATFORM':
            PLATFORM_ = child_.text
            PLATFORM_ = self.gds_validate_string(PLATFORM_, node, 'PLATFORM')
            self.PLATFORM = PLATFORM_
        elif nodeName_ == 'IMPUTATION':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IMPUTATION')
            self.IMPUTATION = ival_
        super(SEQUENCE_VARIATIONType, self).buildChildren(child_, node, nodeName_, True)


# end class SEQUENCE_VARIATIONType


class SEQUENCE_ASSEMBLYType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, NAME=None, PARTIAL=None, COVERAGE=None, PROGRAM=None, PLATFORM=None, MIN_GAP_LENGTH=None):
        self.original_tagname_ = None
        self.NAME = NAME
        self.PARTIAL = PARTIAL
        self.COVERAGE = COVERAGE
        self.PROGRAM = PROGRAM
        self.PLATFORM = PLATFORM
        self.MIN_GAP_LENGTH = MIN_GAP_LENGTH

    def factory(*args_, **kwargs_):
        if SEQUENCE_ASSEMBLYType.subclass:
            return SEQUENCE_ASSEMBLYType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCE_ASSEMBLYType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_NAME(self):
        return self.NAME

    def set_NAME(self, NAME):
        self.NAME = NAME

    def get_PARTIAL(self):
        return self.PARTIAL

    def set_PARTIAL(self, PARTIAL):
        self.PARTIAL = PARTIAL

    def get_COVERAGE(self):
        return self.COVERAGE

    def set_COVERAGE(self, COVERAGE):
        self.COVERAGE = COVERAGE

    def get_PROGRAM(self):
        return self.PROGRAM

    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM

    def get_PLATFORM(self):
        return self.PLATFORM

    def set_PLATFORM(self, PLATFORM):
        self.PLATFORM = PLATFORM

    def get_MIN_GAP_LENGTH(self):
        return self.MIN_GAP_LENGTH

    def set_MIN_GAP_LENGTH(self, MIN_GAP_LENGTH):
        self.MIN_GAP_LENGTH = MIN_GAP_LENGTH

    def hasContent_(self):
        if (
                                        self.NAME is not None or
                                        self.PARTIAL is not None or
                                    self.COVERAGE is not None or
                                self.PROGRAM is not None or
                            self.PLATFORM is not None or
                        self.MIN_GAP_LENGTH is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SEQUENCE_ASSEMBLYType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCE_ASSEMBLYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCE_ASSEMBLYType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCE_ASSEMBLYType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCE_ASSEMBLYType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNAME>%s</%sNAME>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.NAME).encode(ExternalEncoding).decode(), input_name='NAME'), namespace_, eol_))
        if self.PARTIAL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPARTIAL>%s</%sPARTIAL>%s' % (
            namespace_, self.gds_format_boolean(self.PARTIAL, input_name='PARTIAL'), namespace_, eol_))
        if self.COVERAGE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCOVERAGE>%s</%sCOVERAGE>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.COVERAGE).encode(ExternalEncoding).decode(), input_name='COVERAGE'), namespace_, eol_))
        if self.PROGRAM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.PROGRAM).encode(ExternalEncoding).decode(), input_name='PROGRAM'), namespace_, eol_))
        if self.PLATFORM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPLATFORM>%s</%sPLATFORM>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.PLATFORM).encode(ExternalEncoding).decode(), input_name='PLATFORM'), namespace_, eol_))
        if self.MIN_GAP_LENGTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMIN_GAP_LENGTH>%s</%sMIN_GAP_LENGTH>%s' % (
            namespace_, self.gds_format_integer(self.MIN_GAP_LENGTH, input_name='MIN_GAP_LENGTH'), namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NAME':
            NAME_ = child_.text
            NAME_ = self.gds_validate_string(NAME_, node, 'NAME')
            self.NAME = NAME_
        elif nodeName_ == 'PARTIAL':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PARTIAL')
            self.PARTIAL = ival_
        elif nodeName_ == 'COVERAGE':
            COVERAGE_ = child_.text
            COVERAGE_ = self.gds_validate_string(COVERAGE_, node, 'COVERAGE')
            self.COVERAGE = COVERAGE_
        elif nodeName_ == 'PROGRAM':
            PROGRAM_ = child_.text
            PROGRAM_ = self.gds_validate_string(PROGRAM_, node, 'PROGRAM')
            self.PROGRAM = PROGRAM_
        elif nodeName_ == 'PLATFORM':
            PLATFORM_ = child_.text
            PLATFORM_ = self.gds_validate_string(PLATFORM_, node, 'PLATFORM')
            self.PLATFORM = PLATFORM_
        elif nodeName_ == 'MIN_GAP_LENGTH':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MIN_GAP_LENGTH')
            self.MIN_GAP_LENGTH = ival_


# end class SEQUENCE_ASSEMBLYType


class SEQUENCE_ANNOTATIONType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self):
        self.original_tagname_ = None

    def factory(*args_, **kwargs_):
        if SEQUENCE_ANNOTATIONType.subclass:
            return SEQUENCE_ANNOTATIONType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCE_ANNOTATIONType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SEQUENCE_ANNOTATIONType', namespacedef_='',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCE_ANNOTATIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCE_ANNOTATIONType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCE_ANNOTATIONType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCE_ANNOTATIONType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class SEQUENCE_ANNOTATIONType


class SAMPLE_PHENOTYPEType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self):
        self.original_tagname_ = None

    def factory(*args_, **kwargs_):
        if SAMPLE_PHENOTYPEType.subclass:
            return SAMPLE_PHENOTYPEType.subclass(*args_, **kwargs_)
        else:
            return SAMPLE_PHENOTYPEType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SAMPLE_PHENOTYPEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SAMPLE_PHENOTYPEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SAMPLE_PHENOTYPEType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SAMPLE_PHENOTYPEType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='SAMPLE_PHENOTYPEType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class SAMPLE_PHENOTYPEType


class FILESType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, FILE=None):
        self.original_tagname_ = None
        if FILE is None:
            self.FILE = []
        else:
            self.FILE = FILE

    def factory(*args_, **kwargs_):
        if FILESType.subclass:
            return FILESType.subclass(*args_, **kwargs_)
        else:
            return FILESType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_FILE(self):
        return self.FILE

    def set_FILE(self, FILE):
        self.FILE = FILE

    def add_FILE(self, value):
        self.FILE.append(value)

    def insert_FILE_at(self, index, value):
        self.FILE.insert(index, value)

    def replace_FILE_at(self, index, value):
        self.FILE[index] = value

    def hasContent_(self):
        if (
                self.FILE
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='FILESType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FILESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FILESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FILESType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='FILESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FILE_ in self.FILE:
            FILE_.export(outfile, level, namespace_, name_='FILE', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FILE':
            obj_ = AnalysisFileType.factory()
            obj_.build(child_)
            self.FILE.append(obj_)
            obj_.original_tagname_ = 'FILE'


# end class FILESType


class ANALYSIS_LINKSType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, ANALYSIS_LINK=None):
        self.original_tagname_ = None
        if ANALYSIS_LINK is None:
            self.ANALYSIS_LINK = []
        else:
            self.ANALYSIS_LINK = ANALYSIS_LINK

    def factory(*args_, **kwargs_):
        if ANALYSIS_LINKSType.subclass:
            return ANALYSIS_LINKSType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_LINKSType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ANALYSIS_LINK(self):
        return self.ANALYSIS_LINK

    def set_ANALYSIS_LINK(self, ANALYSIS_LINK):
        self.ANALYSIS_LINK = ANALYSIS_LINK

    def add_ANALYSIS_LINK(self, value):
        self.ANALYSIS_LINK.append(value)

    def insert_ANALYSIS_LINK_at(self, index, value):
        self.ANALYSIS_LINK.insert(index, value)

    def replace_ANALYSIS_LINK_at(self, index, value):
        self.ANALYSIS_LINK[index] = value

    def hasContent_(self):
        if (
                self.ANALYSIS_LINK
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ANALYSIS_LINKSType',
               namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANALYSIS_LINKSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ANALYSIS_LINKSType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANALYSIS_LINKSType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ANALYSIS_LINKSType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_LINK_ in self.ANALYSIS_LINK:
            ANALYSIS_LINK_.export(outfile, level, namespace_, name_='ANALYSIS_LINK', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ANALYSIS_LINK':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.ANALYSIS_LINK.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_LINK'


# end class ANALYSIS_LINKSType


class ANALYSIS_ATTRIBUTESType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, ANALYSIS_ATTRIBUTE=None):
        self.original_tagname_ = None
        if ANALYSIS_ATTRIBUTE is None:
            self.ANALYSIS_ATTRIBUTE = []
        else:
            self.ANALYSIS_ATTRIBUTE = ANALYSIS_ATTRIBUTE

    def factory(*args_, **kwargs_):
        if ANALYSIS_ATTRIBUTESType.subclass:
            return ANALYSIS_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return ANALYSIS_ATTRIBUTESType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ANALYSIS_ATTRIBUTE(self):
        return self.ANALYSIS_ATTRIBUTE

    def set_ANALYSIS_ATTRIBUTE(self, ANALYSIS_ATTRIBUTE):
        self.ANALYSIS_ATTRIBUTE = ANALYSIS_ATTRIBUTE

    def add_ANALYSIS_ATTRIBUTE(self, value):
        self.ANALYSIS_ATTRIBUTE.append(value)

    def insert_ANALYSIS_ATTRIBUTE_at(self, index, value):
        self.ANALYSIS_ATTRIBUTE.insert(index, value)

    def replace_ANALYSIS_ATTRIBUTE_at(self, index, value):
        self.ANALYSIS_ATTRIBUTE[index] = value

    def hasContent_(self):
        if (
                self.ANALYSIS_ATTRIBUTE
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ANALYSIS_ATTRIBUTESType',
               namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ANALYSIS_ATTRIBUTESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ANALYSIS_ATTRIBUTESType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ANALYSIS_ATTRIBUTESType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ANALYSIS_ATTRIBUTESType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ANALYSIS_ATTRIBUTE_ in self.ANALYSIS_ATTRIBUTE:
            ANALYSIS_ATTRIBUTE_.export(outfile, level, namespace_, name_='ANALYSIS_ATTRIBUTE',
                                       pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ANALYSIS_ATTRIBUTE':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.ANALYSIS_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'ANALYSIS_ATTRIBUTE'


# end class ANALYSIS_ATTRIBUTESType


class URL_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL

    def factory(*args_, **kwargs_):
        if URL_LINKType.subclass:
            return URL_LINKType.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_URL(self):
        return self.URL

    def set_URL(self, URL):
        self.URL = URL

    def hasContent_(self):
        if (
                        self.LABEL is not None or
                        self.URL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='URL_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding).decode(), input_name='URL'),
            namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_


# end class URL_LINKType


class ENTREZ_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, DB=None, ID=None, QUERY=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.QUERY = QUERY
        self.LABEL = LABEL

    def factory(*args_, **kwargs_):
        if ENTREZ_LINKType.subclass:
            return ENTREZ_LINKType.subclass(*args_, **kwargs_)
        else:
            return ENTREZ_LINKType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_DB(self):
        return self.DB

    def set_DB(self, DB):
        self.DB = DB

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_QUERY(self):
        return self.QUERY

    def set_QUERY(self, QUERY):
        self.QUERY = QUERY

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def hasContent_(self):
        if (
                                self.DB is not None or
                                self.ID is not None or
                            self.QUERY is not None or
                        self.LABEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTREZ_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTREZ_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTREZ_LINKType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding).decode(), input_name='DB'),
            namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write(
                '<%sID>%s</%sID>%s' % (namespace_, self.gds_format_integer(self.ID, input_name='ID'), namespace_, eol_))
        if self.QUERY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQUERY>%s</%sQUERY>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.QUERY).encode(ExternalEncoding).decode(), input_name='QUERY'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'QUERY':
            QUERY_ = child_.text
            QUERY_ = self.gds_validate_string(QUERY_, node, 'QUERY')
            self.QUERY = QUERY_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_


# end class ENTREZ_LINKType


class SPOT_DECODE_SPECType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, SPOT_LENGTH=None, READ_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_LENGTH = SPOT_LENGTH
        if READ_SPEC is None:
            self.READ_SPEC = []
        else:
            self.READ_SPEC = READ_SPEC

    def factory(*args_, **kwargs_):
        if SPOT_DECODE_SPECType.subclass:
            return SPOT_DECODE_SPECType.subclass(*args_, **kwargs_)
        else:
            return SPOT_DECODE_SPECType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_SPOT_LENGTH(self):
        return self.SPOT_LENGTH

    def set_SPOT_LENGTH(self, SPOT_LENGTH):
        self.SPOT_LENGTH = SPOT_LENGTH

    def get_READ_SPEC(self):
        return self.READ_SPEC

    def set_READ_SPEC(self, READ_SPEC):
        self.READ_SPEC = READ_SPEC

    def add_READ_SPEC(self, value):
        self.READ_SPEC.append(value)

    def insert_READ_SPEC_at(self, index, value):
        self.READ_SPEC.insert(index, value)

    def replace_READ_SPEC_at(self, index, value):
        self.READ_SPEC[index] = value

    def hasContent_(self):
        if (
                        self.SPOT_LENGTH is not None or
                    self.READ_SPEC
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SPOT_DECODE_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SPOT_DECODE_SPECType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SPOT_DECODE_SPECType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_LENGTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPOT_LENGTH>%s</%sSPOT_LENGTH>%s' % (
            namespace_, self.gds_format_integer(self.SPOT_LENGTH, input_name='SPOT_LENGTH'), namespace_, eol_))
        for READ_SPEC_ in self.READ_SPEC:
            READ_SPEC_.export(outfile, level, namespace_, name_='READ_SPEC', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_LENGTH':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SPOT_LENGTH')
            self.SPOT_LENGTH = ival_
        elif nodeName_ == 'READ_SPEC':
            obj_ = READ_SPECType.factory()
            obj_.build(child_)
            self.READ_SPEC.append(obj_)
            obj_.original_tagname_ = 'READ_SPEC'


# end class SPOT_DECODE_SPECType


class READ_SPECType(GeneratedsSuper):
    """There are various methods to ordering the reads on the spot."""
    subclass = None
    superclass = None

    def __init__(self, READ_INDEX=None, READ_LABEL=None, READ_CLASS=None, READ_TYPE='Forward', RELATIVE_ORDER=None,
                 BASE_COORD=None, EXPECTED_BASECALL_TABLE=None):
        self.original_tagname_ = None
        self.READ_INDEX = READ_INDEX
        self.READ_LABEL = READ_LABEL
        self.READ_CLASS = READ_CLASS
        self.validate_READ_CLASSType(self.READ_CLASS)
        self.READ_TYPE = READ_TYPE
        self.validate_READ_TYPEType(self.READ_TYPE)
        self.RELATIVE_ORDER = RELATIVE_ORDER
        self.BASE_COORD = BASE_COORD
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE

    def factory(*args_, **kwargs_):
        if READ_SPECType.subclass:
            return READ_SPECType.subclass(*args_, **kwargs_)
        else:
            return READ_SPECType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_READ_INDEX(self):
        return self.READ_INDEX

    def set_READ_INDEX(self, READ_INDEX):
        self.READ_INDEX = READ_INDEX

    def get_READ_LABEL(self):
        return self.READ_LABEL

    def set_READ_LABEL(self, READ_LABEL):
        self.READ_LABEL = READ_LABEL

    def get_READ_CLASS(self):
        return self.READ_CLASS

    def set_READ_CLASS(self, READ_CLASS):
        self.READ_CLASS = READ_CLASS

    def get_READ_TYPE(self):
        return self.READ_TYPE

    def set_READ_TYPE(self, READ_TYPE):
        self.READ_TYPE = READ_TYPE

    def get_RELATIVE_ORDER(self):
        return self.RELATIVE_ORDER

    def set_RELATIVE_ORDER(self, RELATIVE_ORDER):
        self.RELATIVE_ORDER = RELATIVE_ORDER

    def get_BASE_COORD(self):
        return self.BASE_COORD

    def set_BASE_COORD(self, BASE_COORD):
        self.BASE_COORD = BASE_COORD

    def get_EXPECTED_BASECALL_TABLE(self):
        return self.EXPECTED_BASECALL_TABLE

    def set_EXPECTED_BASECALL_TABLE(self, EXPECTED_BASECALL_TABLE):
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE

    def validate_READ_CLASSType(self, value):
        # Validate type READ_CLASSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Application Read', 'Technical Read']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_CLASSType' % {
                    "value": value.encode("utf-8")})

    def validate_READ_TYPEType(self, value):
        # Validate type READ_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Forward', 'Reverse', 'Adapter', 'Primer', 'Linker', 'BarCode', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_TYPEType' % {
                    "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                                            self.READ_INDEX is not None or
                                            self.READ_LABEL is not None or
                                        self.READ_CLASS is not None or
                                    self.READ_TYPE != "Forward" or
                                self.RELATIVE_ORDER is not None or
                            self.BASE_COORD is not None or
                        self.EXPECTED_BASECALL_TABLE is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='READ_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='READ_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='READ_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='READ_SPECType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='READ_SPECType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.READ_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_INDEX>%s</%sREAD_INDEX>%s' % (
            namespace_, self.gds_format_integer(self.READ_INDEX, input_name='READ_INDEX'), namespace_, eol_))
        if self.READ_LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.READ_LABEL).encode(ExternalEncoding).decode(), input_name='READ_LABEL'), namespace_,
                                                                 eol_))
        if self.READ_CLASS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_CLASS>%s</%sREAD_CLASS>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.READ_CLASS).encode(ExternalEncoding).decode(), input_name='READ_CLASS'), namespace_,
                                                                 eol_))
        if self.READ_TYPE != "Forward":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.READ_TYPE).encode(ExternalEncoding).decode(), input_name='READ_TYPE'), namespace_, eol_))
        if self.RELATIVE_ORDER is not None:
            self.RELATIVE_ORDER.export(outfile, level, namespace_, name_='RELATIVE_ORDER', pretty_print=pretty_print)
        if self.BASE_COORD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBASE_COORD>%s</%sBASE_COORD>%s' % (
            namespace_, self.gds_format_integer(self.BASE_COORD, input_name='BASE_COORD'), namespace_, eol_))
        if self.EXPECTED_BASECALL_TABLE is not None:
            self.EXPECTED_BASECALL_TABLE.export(outfile, level, namespace_, name_='EXPECTED_BASECALL_TABLE',
                                                pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'READ_INDEX':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'READ_INDEX')
            self.READ_INDEX = ival_
        elif nodeName_ == 'READ_LABEL':
            READ_LABEL_ = child_.text
            READ_LABEL_ = self.gds_validate_string(READ_LABEL_, node, 'READ_LABEL')
            self.READ_LABEL = READ_LABEL_
        elif nodeName_ == 'READ_CLASS':
            READ_CLASS_ = child_.text
            READ_CLASS_ = self.gds_validate_string(READ_CLASS_, node, 'READ_CLASS')
            self.READ_CLASS = READ_CLASS_
            # validate type READ_CLASSType
            self.validate_READ_CLASSType(self.READ_CLASS)
        elif nodeName_ == 'READ_TYPE':
            READ_TYPE_ = child_.text
            READ_TYPE_ = self.gds_validate_string(READ_TYPE_, node, 'READ_TYPE')
            self.READ_TYPE = READ_TYPE_
            # validate type READ_TYPEType
            self.validate_READ_TYPEType(self.READ_TYPE)
        elif nodeName_ == 'RELATIVE_ORDER':
            obj_ = RELATIVE_ORDERType.factory()
            obj_.build(child_)
            self.RELATIVE_ORDER = obj_
            obj_.original_tagname_ = 'RELATIVE_ORDER'
        elif nodeName_ == 'BASE_COORD':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BASE_COORD')
            self.BASE_COORD = ival_
        elif nodeName_ == 'EXPECTED_BASECALL_TABLE':
            obj_ = EXPECTED_BASECALL_TABLEType.factory()
            obj_.build(child_)
            self.EXPECTED_BASECALL_TABLE = obj_
            obj_.original_tagname_ = 'EXPECTED_BASECALL_TABLE'


# end class READ_SPECType


class RELATIVE_ORDERType(GeneratedsSuper):
    """Specify the read index that precedes this read. Specify the read
    index that follows this read."""
    subclass = None
    superclass = None

    def __init__(self, follows_read_index=None, precedes_read_index=None):
        self.original_tagname_ = None
        self.follows_read_index = _cast(int, follows_read_index)
        self.precedes_read_index = _cast(int, precedes_read_index)

    def factory(*args_, **kwargs_):
        if RELATIVE_ORDERType.subclass:
            return RELATIVE_ORDERType.subclass(*args_, **kwargs_)
        else:
            return RELATIVE_ORDERType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_follows_read_index(self):
        return self.follows_read_index

    def set_follows_read_index(self, follows_read_index):
        self.follows_read_index = follows_read_index

    def get_precedes_read_index(self):
        return self.precedes_read_index

    def set_precedes_read_index(self, precedes_read_index):
        self.precedes_read_index = precedes_read_index

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RELATIVE_ORDERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RELATIVE_ORDERType',
                                pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RELATIVE_ORDERType'):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            outfile.write(' follows_read_index="%s"' % self.gds_format_integer(self.follows_read_index,
                                                                               input_name='follows_read_index'))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            outfile.write(' precedes_read_index="%s"' % self.gds_format_integer(self.precedes_read_index,
                                                                                input_name='precedes_read_index'))

    def exportChildren(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('follows_read_index', node)
        if value is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            try:
                self.follows_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.follows_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('precedes_read_index', node)
        if value is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            try:
                self.precedes_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.precedes_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class RELATIVE_ORDERType


class EXPECTED_BASECALL_TABLEType(GeneratedsSuper):
    """Specify whether the spot should have a default length for this tag
    if the expected base cannot be matched. Specify an optional
    starting point for tag (base offset from 1)."""
    subclass = None
    superclass = None

    def __init__(self, default_length=None, base_coord=None, BASECALL=None):
        self.original_tagname_ = None
        self.default_length = _cast(int, default_length)
        self.base_coord = _cast(int, base_coord)
        if BASECALL is None:
            self.BASECALL = []
        else:
            self.BASECALL = BASECALL

    def factory(*args_, **kwargs_):
        if EXPECTED_BASECALL_TABLEType.subclass:
            return EXPECTED_BASECALL_TABLEType.subclass(*args_, **kwargs_)
        else:
            return EXPECTED_BASECALL_TABLEType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_BASECALL(self):
        return self.BASECALL

    def set_BASECALL(self, BASECALL):
        self.BASECALL = BASECALL

    def add_BASECALL(self, value):
        self.BASECALL.append(value)

    def insert_BASECALL_at(self, index, value):
        self.BASECALL.insert(index, value)

    def replace_BASECALL_at(self, index, value):
        self.BASECALL[index] = value

    def get_default_length(self):
        return self.default_length

    def set_default_length(self, default_length):
        self.default_length = default_length

    def get_base_coord(self):
        return self.base_coord

    def set_base_coord(self, base_coord):
        self.base_coord = base_coord

    def hasContent_(self):
        if (
                self.BASECALL
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', namespacedef_='',
               pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPECTED_BASECALL_TABLEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPECTED_BASECALL_TABLEType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPECTED_BASECALL_TABLEType'):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            outfile.write(
                ' default_length="%s"' % self.gds_format_integer(self.default_length, input_name='default_length'))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            outfile.write(' base_coord="%s"' % self.gds_format_integer(self.base_coord, input_name='base_coord'))

    def exportChildren(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BASECALL_ in self.BASECALL:
            BASECALL_.export(outfile, level, namespace_, name_='BASECALL', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_length', node)
        if value is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            try:
                self.default_length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.default_length < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('base_coord', node)
        if value is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            try:
                self.base_coord = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.base_coord < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BASECALL':
            obj_ = BASECALLType.factory()
            obj_.build(child_)
            self.BASECALL.append(obj_)
            obj_.original_tagname_ = 'BASECALL'


# end class EXPECTED_BASECALL_TABLEType


class BASECALLType(GeneratedsSuper):
    """When match occurs, the read will be tagged with this group
    membership Minimum number of matches to trigger identification.
    Maximum number of mismatches Where the match should occur.
    Changes the rules on how min_match and max_mismatch are counted.
    Only @max_mismatch influences matching process Both matches and
    mismatches are counted. When @max_mismatch is exceeded - it is
    not a match. When @min_match is reached - match is declared.
    Both matches and mismatches are counted. When @max_mismatch is
    exceeded - it is not a match. When @min_match is reached - match
    is declared."""
    subclass = None
    superclass = None

    def __init__(self, max_mismatch=None, min_match=None, match_edge=None, read_group_tag=None, valueOf_=None):
        self.original_tagname_ = None
        self.max_mismatch = _cast(int, max_mismatch)
        self.min_match = _cast(int, min_match)
        self.match_edge = _cast(None, match_edge)
        self.read_group_tag = _cast(None, read_group_tag)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if BASECALLType.subclass:
            return BASECALLType.subclass(*args_, **kwargs_)
        else:
            return BASECALLType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_max_mismatch(self):
        return self.max_mismatch

    def set_max_mismatch(self, max_mismatch):
        self.max_mismatch = max_mismatch

    def get_min_match(self):
        return self.min_match

    def set_min_match(self, min_match):
        self.min_match = min_match

    def get_match_edge(self):
        return self.match_edge

    def set_match_edge(self, match_edge):
        self.match_edge = match_edge

    def get_read_group_tag(self):
        return self.read_group_tag

    def set_read_group_tag(self, read_group_tag):
        self.read_group_tag = read_group_tag

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
                self.valueOf_
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='BASECALLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BASECALLType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding).decode())
            self.exportChildren(outfile, level + 1, namespace_='', name_='BASECALLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BASECALLType'):
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            outfile.write(' max_mismatch="%s"' % self.gds_format_integer(self.max_mismatch, input_name='max_mismatch'))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            outfile.write(' min_match="%s"' % self.gds_format_integer(self.min_match, input_name='min_match'))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            outfile.write(' match_edge=%s' % (
            self.gds_format_string(quote_attrib(self.match_edge).encode(ExternalEncoding).decode(),
                                   input_name='match_edge'),))
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (
            self.gds_format_string(quote_attrib(self.read_group_tag).encode(ExternalEncoding).decode(),
                                   input_name='read_group_tag'),))

    def exportChildren(self, outfile, level, namespace_='', name_='BASECALLType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_mismatch', node)
        if value is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            try:
                self.max_mismatch = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.max_mismatch < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('min_match', node)
        if value is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            try:
                self.min_match = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.min_match < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('match_edge', node)
        if value is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            self.match_edge = value
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class BASECALLType


class LS454Type(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if LS454Type.subclass:
            return LS454Type.subclass(*args_, **kwargs_)
        else:
            return LS454Type(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType(self, value):
        # Validate type INSTRUMENT_MODELType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['454 GS', '454 GS 20', '454 GS FLX', '454 GS FLX+', '454 GS FLX Titanium', '454 GS Junior',
                            'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='LS454Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LS454Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LS454Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LS454Type'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='LS454Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType
            self.validate_INSTRUMENT_MODELType(self.INSTRUMENT_MODEL)


# end class LS454Type


class ILLUMINAType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType1(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if ILLUMINAType.subclass:
            return ILLUMINAType.subclass(*args_, **kwargs_)
        else:
            return ILLUMINAType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType1(self, value):
        # Validate type INSTRUMENT_MODELType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Illumina Genome Analyzer', 'Illumina Genome Analyzer II', 'Illumina Genome Analyzer IIx',
                            'Illumina HiSeq 2500', 'Illumina HiSeq 2000', 'Illumina HiSeq 1000', 'Illumina MiSeq',
                            'Illumina HiScanSQ', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType1' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ILLUMINAType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ILLUMINAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ILLUMINAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ILLUMINAType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ILLUMINAType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType1
            self.validate_INSTRUMENT_MODELType1(self.INSTRUMENT_MODEL)


# end class ILLUMINAType


class HELICOSType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType2(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if HELICOSType.subclass:
            return HELICOSType.subclass(*args_, **kwargs_)
        else:
            return HELICOSType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType2(self, value):
        # Validate type INSTRUMENT_MODELType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Helicos HeliScope', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType2' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='HELICOSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HELICOSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HELICOSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HELICOSType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='HELICOSType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType2
            self.validate_INSTRUMENT_MODELType2(self.INSTRUMENT_MODEL)


# end class HELICOSType


class ABI_SOLIDType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType3(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if ABI_SOLIDType.subclass:
            return ABI_SOLIDType.subclass(*args_, **kwargs_)
        else:
            return ABI_SOLIDType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType3(self, value):
        # Validate type INSTRUMENT_MODELType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB SOLiD System', 'AB SOLiD System 2.0', 'AB SOLiD System 3.0', 'AB SOLiD 3 Plus System',
                            'AB SOLiD 4 System', 'AB SOLiD 4hq System', 'AB SOLiD PI System',
                            'AB 5500 Genetic Analyzer', 'AB 5500xl Genetic Analyzer', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType3' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ABI_SOLIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ABI_SOLIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ABI_SOLIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ABI_SOLIDType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ABI_SOLIDType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType3
            self.validate_INSTRUMENT_MODELType3(self.INSTRUMENT_MODEL)


# end class ABI_SOLIDType


class COMPLETE_GENOMICSType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType4(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if COMPLETE_GENOMICSType.subclass:
            return COMPLETE_GENOMICSType.subclass(*args_, **kwargs_)
        else:
            return COMPLETE_GENOMICSType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType4(self, value):
        # Validate type INSTRUMENT_MODELType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Complete Genomics', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType4' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMPLETE_GENOMICSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMPLETE_GENOMICSType',
                                pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMPLETE_GENOMICSType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType4
            self.validate_INSTRUMENT_MODELType4(self.INSTRUMENT_MODEL)


# end class COMPLETE_GENOMICSType


class PACBIO_SMRTType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType5(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if PACBIO_SMRTType.subclass:
            return PACBIO_SMRTType.subclass(*args_, **kwargs_)
        else:
            return PACBIO_SMRTType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType5(self, value):
        # Validate type INSTRUMENT_MODELType5, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PacBio RS', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType5' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PACBIO_SMRTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PACBIO_SMRTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PACBIO_SMRTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType5
            self.validate_INSTRUMENT_MODELType5(self.INSTRUMENT_MODEL)


# end class PACBIO_SMRTType


class ION_TORRENTType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType6(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if ION_TORRENTType.subclass:
            return ION_TORRENTType.subclass(*args_, **kwargs_)
        else:
            return ION_TORRENTType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType6(self, value):
        # Validate type INSTRUMENT_MODELType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Ion Torrent PGM', 'Ion Torrent Proton', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType6' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='ION_TORRENTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ION_TORRENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ION_TORRENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ION_TORRENTType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='ION_TORRENTType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType6
            self.validate_INSTRUMENT_MODELType6(self.INSTRUMENT_MODEL)


# end class ION_TORRENTType


class CAPILLARYType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_INSTRUMENT_MODELType7(self.INSTRUMENT_MODEL)

    def factory(*args_, **kwargs_):
        if CAPILLARYType.subclass:
            return CAPILLARYType.subclass(*args_, **kwargs_)
        else:
            return CAPILLARYType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_INSTRUMENT_MODEL(self):
        return self.INSTRUMENT_MODEL

    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL):
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL

    def validate_INSTRUMENT_MODELType7(self, value):
        # Validate type INSTRUMENT_MODELType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB 3730xL Genetic Analyzer', 'AB 3730 Genetic Analyzer', 'AB 3500xL Genetic Analyzer',
                            'AB 3500 Genetic Analyzer', 'AB 3130xL Genetic Analyzer', 'AB 3130 Genetic Analyzer',
                            'AB 310 Genetic Analyzer', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn(
                    'Value "%(value)s" does not match xsd enumeration restriction on INSTRUMENT_MODELType7' % {
                        "value": value.encode("utf-8")})

    def hasContent_(self):
        if (
                    self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='CAPILLARYType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CAPILLARYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CAPILLARYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CAPILLARYType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='CAPILLARYType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding).decode(), input_name='INSTRUMENT_MODEL'),
                                                                             namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type INSTRUMENT_MODELType7
            self.validate_INSTRUMENT_MODELType7(self.INSTRUMENT_MODEL)


# end class CAPILLARYType


class PIPE_SECTIONType(GeneratedsSuper):
    """Name of the processing pipeline section."""
    subclass = None
    superclass = None

    def __init__(self, section_name=None, STEP_INDEX=None, PREV_STEP_INDEX=None, PROGRAM=None, VERSION=None,
                 NOTES=None):
        self.original_tagname_ = None
        self.section_name = _cast(None, section_name)
        self.STEP_INDEX = STEP_INDEX
        if PREV_STEP_INDEX is None:
            self.PREV_STEP_INDEX = []
        else:
            self.PREV_STEP_INDEX = PREV_STEP_INDEX
        self.PROGRAM = PROGRAM
        self.VERSION = VERSION
        self.NOTES = NOTES

    def factory(*args_, **kwargs_):
        if PIPE_SECTIONType.subclass:
            return PIPE_SECTIONType.subclass(*args_, **kwargs_)
        else:
            return PIPE_SECTIONType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_STEP_INDEX(self):
        return self.STEP_INDEX

    def set_STEP_INDEX(self, STEP_INDEX):
        self.STEP_INDEX = STEP_INDEX

    def get_PREV_STEP_INDEX(self):
        return self.PREV_STEP_INDEX

    def set_PREV_STEP_INDEX(self, PREV_STEP_INDEX):
        self.PREV_STEP_INDEX = PREV_STEP_INDEX

    def add_PREV_STEP_INDEX(self, value):
        self.PREV_STEP_INDEX.append(value)

    def insert_PREV_STEP_INDEX_at(self, index, value):
        self.PREV_STEP_INDEX.insert(index, value)

    def replace_PREV_STEP_INDEX_at(self, index, value):
        self.PREV_STEP_INDEX[index] = value

    def get_PROGRAM(self):
        return self.PROGRAM

    def set_PROGRAM(self, PROGRAM):
        self.PROGRAM = PROGRAM

    def get_VERSION(self):
        return self.VERSION

    def set_VERSION(self, VERSION):
        self.VERSION = VERSION

    def get_NOTES(self):
        return self.NOTES

    def set_NOTES(self, NOTES):
        self.NOTES = NOTES

    def get_section_name(self):
        return self.section_name

    def set_section_name(self, section_name):
        self.section_name = section_name

    def hasContent_(self):
        if (
                                    self.STEP_INDEX is not None or
                                self.PREV_STEP_INDEX or
                                self.PROGRAM is not None or
                            self.VERSION is not None or
                        self.NOTES is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PIPE_SECTIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PIPE_SECTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PIPE_SECTIONType'):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            outfile.write(' section_name=%s' % (
            self.gds_format_string(quote_attrib(self.section_name).encode(ExternalEncoding).decode(),
                                   input_name='section_name'),))

    def exportChildren(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STEP_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTEP_INDEX>%s</%sSTEP_INDEX>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.STEP_INDEX).encode(ExternalEncoding).decode(), input_name='STEP_INDEX'), namespace_,
                                                                 eol_))
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STEP_INDEX>%s</%sPREV_STEP_INDEX>%s' % (namespace_, self.gds_format_string(
                quote_xml(PREV_STEP_INDEX_).encode(ExternalEncoding).decode(), input_name='PREV_STEP_INDEX'),
                                                                           namespace_, eol_))
        if self.PROGRAM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.PROGRAM).encode(ExternalEncoding).decode(), input_name='PROGRAM'), namespace_, eol_))
        if self.VERSION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.VERSION).encode(ExternalEncoding).decode(), input_name='VERSION'), namespace_, eol_))
        if self.NOTES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNOTES>%s</%sNOTES>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.NOTES).encode(ExternalEncoding).decode(), input_name='NOTES'), namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('section_name', node)
        if value is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            self.section_name = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STEP_INDEX':
            STEP_INDEX_ = child_.text
            STEP_INDEX_ = self.gds_validate_string(STEP_INDEX_, node, 'STEP_INDEX')
            self.STEP_INDEX = STEP_INDEX_
        elif nodeName_ == 'PREV_STEP_INDEX':
            PREV_STEP_INDEX_ = child_.text
            PREV_STEP_INDEX_ = self.gds_validate_string(PREV_STEP_INDEX_, node, 'PREV_STEP_INDEX')
            self.PREV_STEP_INDEX.append(PREV_STEP_INDEX_)
        elif nodeName_ == 'PROGRAM':
            PROGRAM_ = child_.text
            PROGRAM_ = self.gds_validate_string(PROGRAM_, node, 'PROGRAM')
            self.PROGRAM = PROGRAM_
        elif nodeName_ == 'VERSION':
            VERSION_ = child_.text
            VERSION_ = self.gds_validate_string(VERSION_, node, 'VERSION')
            self.VERSION = VERSION_
        elif nodeName_ == 'NOTES':
            NOTES_ = child_.text
            NOTES_ = self.gds_validate_string(NOTES_, node, 'NOTES')
            self.NOTES = NOTES_


# end class PIPE_SECTIONType


class STANDARDType(GeneratedsSuper):
    """A recognized name for the genome assembly.Identifies the genome
    assembly using an accession number and a sequence version."""
    subclass = None
    superclass = None

    def __init__(self, refname=None, accession=None):
        self.original_tagname_ = None
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)

    def factory(*args_, **kwargs_):
        if STANDARDType.subclass:
            return STANDARDType.subclass(*args_, **kwargs_)
        else:
            return STANDARDType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_refname(self):
        return self.refname

    def set_refname(self, refname):
        self.refname = refname

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='STANDARDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STANDARDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='STANDARDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STANDARDType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (
            self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(),
                                   input_name='refname'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))

    def exportChildren(self, outfile, level, namespace_='', name_='STANDARDType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class STANDARDType


class CUSTOMType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, DESCRIPTION=None, URL_LINK=None):
        self.original_tagname_ = None
        self.DESCRIPTION = DESCRIPTION
        if URL_LINK is None:
            self.URL_LINK = []
        else:
            self.URL_LINK = URL_LINK

    def factory(*args_, **kwargs_):
        if CUSTOMType.subclass:
            return CUSTOMType.subclass(*args_, **kwargs_)
        else:
            return CUSTOMType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_DESCRIPTION(self):
        return self.DESCRIPTION

    def set_DESCRIPTION(self, DESCRIPTION):
        self.DESCRIPTION = DESCRIPTION

    def get_URL_LINK(self):
        return self.URL_LINK

    def set_URL_LINK(self, URL_LINK):
        self.URL_LINK = URL_LINK

    def add_URL_LINK(self, value):
        self.URL_LINK.append(value)

    def insert_URL_LINK_at(self, index, value):
        self.URL_LINK.insert(index, value)

    def replace_URL_LINK_at(self, index, value):
        self.URL_LINK[index] = value

    def hasContent_(self):
        if (
                        self.DESCRIPTION is not None or
                    self.URL_LINK
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='CUSTOMType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CUSTOMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CUSTOMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CUSTOMType'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='CUSTOMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.DESCRIPTION).encode(ExternalEncoding).decode(), input_name='DESCRIPTION'), namespace_,
                                                                   eol_))
        for URL_LINK_ in self.URL_LINK:
            URL_LINK_.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
        elif nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType8.factory()
            obj_.build(child_)
            self.URL_LINK.append(obj_)
            obj_.original_tagname_ = 'URL_LINK'


# end class CUSTOMType


class URL_LINKType8(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL

    def factory(*args_, **kwargs_):
        if URL_LINKType8.subclass:
            return URL_LINKType8.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType8(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_URL(self):
        return self.URL

    def set_URL(self, URL):
        self.URL = URL

    def hasContent_(self):
        if (
                        self.LABEL is not None or
                        self.URL is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='URL_LINKType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType8'):
        pass

    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType8', fromsubclass_=False,
                       pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(
                quote_xml(self.LABEL).encode(ExternalEncoding).decode(), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (
            namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding).decode(), input_name='URL'),
            namespace_, eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_


# end class URL_LINKType8


class SEQUENCEType(GeneratedsSuper):
    """A recognized name for the reference sequence. Accession.version with
    version being mandatory This is how Reference Sequence is
    labeled in submission file(s). It is equivalent to SQ label in
    BAM. Optional when submitted file uses INSDC accession.version"""
    subclass = None
    superclass = None

    def __init__(self, label=None, refname=None, accession=None):
        self.original_tagname_ = None
        self.label = _cast(None, label)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)

    def factory(*args_, **kwargs_):
        if SEQUENCEType.subclass:
            return SEQUENCEType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCEType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def get_refname(self):
        return self.refname

    def set_refname(self, refname):
        self.refname = refname

    def get_accession(self):
        return self.accession

    def set_accession(self, accession):
        self.accession = accession

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='SEQUENCEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCEType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (
            self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding).decode(), input_name='label'),))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (
            self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding).decode(),
                                   input_name='refname'),))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (
            self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding).decode(),
                                   input_name='accession'),))

    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCEType', fromsubclass_=False,
                       pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass


# end class SEQUENCEType


GDSClassesMapping = {
    'SEQUENCE_VARIATION': SEQUENCE_VARIATIONType,
    'IDENTIFIERS': IdentifierType,
    'URL_LINK': URL_LINKType8,
    'FILE': AnalysisFileType,
    'ANALYSIS_TYPE': ANALYSIS_TYPEType,
    'SAMPLE_PHENOTYPE': SAMPLE_PHENOTYPEType,
    'ANALYSIS_LINK': LinkType,
    'COMPLETE_GENOMICS': COMPLETE_GENOMICSType,
    'LS454': LS454Type,
    'ANALYSIS_REF': ANALYSIS_REFType,
    'ILLUMINA': ILLUMINAType,
    'REFERENCE_ALIGNMENT': ReferenceSequenceType,
    'CUSTOM': CUSTOMType,
    'PRIMARY_ID': NameType,
    'ANALYSIS_SET': AnalysisSetType,
    'PIPE_SECTION': PIPE_SECTIONType,
    'SEQUENCE_ANNOTATION': SEQUENCE_ANNOTATIONType,
    'ENTREZ_LINK': ENTREZ_LINKType,
    'XREF_LINK': XRefType,
    'CAPILLARY': CAPILLARYType,
    'RUN_REF': RUN_REFType,
    'ABI_SOLID': ABI_SOLIDType,
    'ASSEMBLY': ReferenceAssemblyType,
    'SEQUENCE': SEQUENCEType,
    'ANALYSIS_ATTRIBUTES': ANALYSIS_ATTRIBUTESType,
    'STANDARD': STANDARDType,
    'SAMPLE_REF': SAMPLE_REFType,
    'STUDY_REF': STUDY_REFType,
    'ION_TORRENT': ION_TORRENTType,
    'SPOT_DECODE_SPEC': SPOT_DECODE_SPECType,
    'EXPECTED_BASECALL_TABLE': EXPECTED_BASECALL_TABLEType,
    'BASECALL': BASECALLType,
    'HELICOS': HELICOSType,
    'FILES': FILESType,
    'PIPELINE': PipelineType,
    'UUID': NameType,
    'ANALYSIS_LINKS': ANALYSIS_LINKSType,
    'CHECKLIST': CHECKLISTType,
    'SEQUENCE_ASSEMBLY': SEQUENCE_ASSEMBLYType,
    'ANALYSIS': AnalysisType,
    'SUBMITTER_ID': QualifiedNameType,
    'SECONDARY_ID': NameType,
    'RELATIVE_ORDER': RELATIVE_ORDERType,
    'DIRECTIVES': SequencingDirectivesType,
    'PACBIO_SMRT': PACBIO_SMRTType,
    'EXTERNAL_ID': QualifiedNameType,
    'ANALYSIS_ATTRIBUTE': AttributeType,
    'READ_SPEC': READ_SPECType,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnalysisFileType'
        rootClass = AnalysisFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnalysisFileType'
        rootClass = AnalysisFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnalysisFileType'
        rootClass = AnalysisFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'AnalysisFileType'
        rootClass = AnalysisFileType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from SRA_analysis import *\n\n')
        sys.stdout.write('import SRA_analysis as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    # import pdb; pdb.set_trace()
    main()

__all__ = [
    "ABI_SOLIDType",
    "ANALYSIS_ATTRIBUTESType",
    "ANALYSIS_LINKSType",
    "ANALYSIS_REFType",
    "ANALYSIS_TYPEType",
    "AnalysisFileType",
    "AnalysisSetType",
    "AnalysisType",
    "AttributeType",
    "BASECALLType",
    "CAPILLARYType",
    "CHECKLISTType",
    "COMPLETE_GENOMICSType",
    "CUSTOMType",
    "ENTREZ_LINKType",
    "EXPECTED_BASECALL_TABLEType",
    "FILESType",
    "HELICOSType",
    "ILLUMINAType",
    "ION_TORRENTType",
    "IdentifierType",
    "LS454Type",
    "LinkType",
    "NameType",
    "PACBIO_SMRTType",
    "PIPE_SECTIONType",
    "PipelineType",
    "PlatformType",
    "ProcessingType",
    "QualifiedNameType",
    "READ_SPECType",
    "REFERENCE_SEQUENCE",
    "RELATIVE_ORDERType",
    "RUN_REFType",
    "ReferenceAssemblyType",
    "ReferenceSequenceType",
    "SAMPLE_PHENOTYPEType",
    "SAMPLE_REFType",
    "SEQUENCEType",
    "SEQUENCE_ANNOTATIONType",
    "SEQUENCE_ASSEMBLYType",
    "SEQUENCE_VARIATIONType",
    "SPOT_DECODE_SPECType",
    "STANDARDType",
    "STUDY_REFType",
    "SequencingDirectivesType",
    "SpotDescriptorType",
    "URLType",
    "URL_LINKType",
    "URL_LINKType8",
    "XRefType"
]
